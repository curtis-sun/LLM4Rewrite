{"index": 0, "conditions": "- Column transformations in the query prevent the use of indexes (e.g., applying `lower()` function, casting types like `update_ts::date`).\n- Selection criteria do not align with indexed column values due to transformations or require implicit transformations (e.g., `coalesce()` function).\n- Queries not structured to utilize existing functional indexes or contain conditions that hinder the use of indexes.", "transformations": "- Modifying selection criteria to avoid unnecessary column transformations, such as by expanding the query's range to match the full timestamp range for date comparisons or by adjusting conditions to avoid implicit transformations.\n- Rewriting queries to directly use indexed columns without applying transformations on them or adjusting queries to use transformations in an index-compatible manner.\n- Before creating new functional indexes, restructure queries to either eliminate unnecessary transformations or ensure they're compatible with existing indexes, hence improving the efficiency of index use by the query optimizer."}
{"index": 1, "conditions": "The SQL query rewrite rule for Index Condition Pushdown (ICP) applies when:\n1. The `WHERE` clause uses index columns.\n2. Queries have conditions that can be partially satisfied using indexed columns.\n3. Range conditions within the `WHERE` clause can be extracted and simplified.\n4. Overlapping intervals and nested `AND`/`OR` constructs are present in the `WHERE` clause.\n5. Conditions within `AND` groups in the `WHERE` clause need to be covered by an index.\n6. Each condition in `OR` constructs uses a part of the same index.", "transformations": "The SQL transformations for the Index Condition Pushdown (ICP) and related optimizations involve:\n1. Processing parts of the `WHERE` clause that use index columns before accessing the full table row, reducing unnecessary row reads.\n2. Extracting and simplifying range conditions within the `WHERE` clause by:\n   - Merging overlapping intervals.\n   - Adjusting conditions based on logical operators to produce a broader, yet efficient, range scan.\n3. Ensuring logical constructs (`AND`/`OR`) within `WHERE` clauses are optimized by:\n   - Utilizing indexes effectively when `OR` conditions each use a part of the same index.\n   - Requiring conditions within `AND` groups to be covered by an index to ensure efficient query execution."}
{"index": 2, "conditions": "- The query does not contain a `GROUP BY` clause.\n- The query does not utilize aggregate functions (e.g., `SUM`, `COUNT`, `AVG`).", "transformations": "- Merge conditions from the `HAVING` clause into the `WHERE` clause."}
{"index": 3, "conditions": "The application of JOIN transformations for query optimization is determined by several conditions:\n- Presence of subqueries with predicates such as `IN`, `EXISTS`, `NOT IN`, and `NOT EXISTS`.\n- Correlation between the main query and subqueries, particularly for semi-join optimizations.\n- Requirement to reduce result set size early in query processing using semi-join for predicates like `IN`, `= ANY`, and `EXISTS`.\n- Need for filtering out rows without matches in anti-join optimizations for `NOT IN` and `NOT EXISTS` predicates.\n- Situations where duplicate rows do not adversely affect the results, facilitating the direct use of JOINs over `EXISTS` or `IN`.\n- Scenarios demanding the negation of subqueries and efficient handling of NULL values, making outer joins combined with NULL value filtering a preferable approach for anti-joins.", "transformations": "1. **Semi-Join Optimizations:**\n   - Application of methods such as table pullout, duplicate weedout, first match, loose scan, and materialization.\n   - Transformation involves discarding non-matching rows in the outer query earlier, possibly by pulling relevant data into a temporary structure or scanning data in a manner that avoids processing duplicate information unnecessarily.\n   \n2. **Anti-Join Optimizations:**\n   - Utilization of explicit JOINs for negated subqueries, especially transforming `NOT IN` and `NOT EXISTS` into configurations that efficiently exclude non-matching rows.\n   - Optimization might include the use of LEFT OUTER JOIN combined with WHERE clauses that filter on NULL values from the right table of the JOIN, effectively implementing the anti-join pattern.\n   \n3. **General JOIN Optimizations:**\n   - Recommending explicit JOINs over `EXISTS` or `IN` operators to leverage database optimizations for JOIN operations, which might include better use of indexes and optimized data access paths.\n   - Optimization through the selection of appropriate JOIN types (e.g., INNER JOIN, LEFT OUTER JOIN) based on the query's requirements and the expected data distributions, ensuring that the execution strategy minimizes resource usage while maximizing performance.\n\nThis approach underscores a tailored execution strategy selection, prioritizing JOIN transformations that align with the query's specific predicates and the correlation dynamics between queries and subqueries."}
{"index": 4, "conditions": "1. The original query uses the `LIKE` operator for pattern matching where the pattern begins with a wildcard (`%`), which typically prevents the efficient use of indexes.\n2. The query uses the `LIKE` operator with patterns that could be optimized to leverage index usage by avoiding the starting wildcard or by using range comparisons.\n3. The query uses case transformation functions like `LOWER()` within `LIKE` expressions, which can impact the effective use of indexes unless an index on the expression or a computed column is used.", "transformations": "1. When the pattern in a `LIKE` clause starts with a wildcard (e.g., `%Patrick%`), rewrite the pattern to eliminate the leading wildcard when possible (e.g., use `LIKE 'Pat%_ck%'` instead) for better index utilization.\n2. Replace `LIKE` patterns that can be expressed as ranges (especially when leading wildcards are used or when the pattern is case-insensitive) with range comparisons using the greater than (`>=`) and less than (`<`) operators. For example, instead of `lower(column) LIKE 'johns%'`, use a range comparison: `column >= 'johns' AND column < 'johnt'`, assuming appropriate case adjustments to match the original intent.\n3. For case-insensitive searches requiring functions like `LOWER(column) LIKE 'value%'`, consider adding an index on the expression `LOWER(column)` or a computed column to maintain the efficiency of index usage."}
{"index": 5, "conditions": "The SQL query rewrite rule applies when:\n- The performance of the query may benefit from avoiding index usage, where direct index lookups are costly or less efficient compared to a full table scan or other execution strategies.\n- The query optimizer defaults to using indexes for column comparisons, but these indexes do not provide the most efficient means of executing the query.\n- Numeric columns (`attr1`) or nullable columns (`t1.attr1`) are involved in the condition clause of the query.", "transformations": "1. **For Numeric Columns:**\n   - Original Condition: `attr1 = p_value`\n   - Transformed Condition: `attr1 + 0 = p_value`\n   - Transformation Logic: By adding zero to the numeric column (`attr1+0`), the optimizer is prevented from using the index on `attr1`, potentially leading to the selection of a more cost-effective execution path such as a full table scan.\n\n2. **For Nullable Columns Comparison:**\n   - Original Condition: `t1.attr2 = t2.attr2`\n   - Transformed Condition: `coalesce(t1.attr2, '0') = coalesce(t2.attr2, '0')`\n   - Transformation Logic: Using the `COALESCE()` function to provide default values for nullable columns in the comparison makes the index on these columns unappealing for the optimizer. This is because `COALESCE()` alters the original expression, thereby guiding the optimizer to possibly consider alternative execution methods other than the index scan."}
{"index": 6, "conditions": "The rule applies to SQL queries with complex `WHERE` clauses that have deep `AND`/`OR` nesting, which might reduce the efficiency of MySQL's execution.", "transformations": "1. Transform `(x AND y) OR z` into `(x OR z) AND (y OR z)`.\n2. Transform `(x OR y) AND z` into `(x AND z) OR (y AND z)`."}
{"index": 7, "conditions": "The SQL conditions to apply this SQL query rewrite rule include:\n- There exists more than one index on the same table that can be utilized for the query.\n- The query involves filtering data based on multiple conditions (e.g., specific columns like departure and arrival times, airports, date ranges in a 'flight' table).\n- The optimizer determines that using bitmaps for separate indexes and combining them with logical operations (AND/OR) to filter rows meets the performance objectives more efficiently than accessing the table directly or using a single index.\n- An efficiency analysis is performed to ensure that the use of multiple indexes (and subsequent bitmap creation and operation) is beneficial, i.e., the benefit of faster data access and filtering outweighs the indexing overhead.", "transformations": "The SQL transformations associated with this rewrite rule involve:\n- Constructing in-memory bitmaps for each index involved in the query. Each bitmap corresponds to a specific index and represents the presence (or absence) of rows meeting the index\u2019s filter criteria.\n- Combining the constructed bitmaps using logical AND or OR operations according to whether the query requires satisfying all conditions simultaneously (AND) or any of them (OR). This step effectively filters out rows that do not meet the query criteria before accessing table data.\n- Proceeding with query execution using the filtered set of table blocks identified by the combined bitmap, significantly reducing the amount of data that has to be read and processed.\n- Optionally, omitting the use of an additional index if the derived data subset from existing indexes is already narrow enough, thereby avoiding unnecessary overhead."}
{"index": 8, "conditions": "- A `LEFT JOIN` is used in the query.\n- The `WHERE` clause includes conditions that inherently reject null values (null-rejected conditions). These can be specific comparisons that are always false for NULL values, such as `col_name IS NOT NULL` where `col_name` comes from a table that is left joined and is guaranteed to be `NOT NULL` in the base table, or other explicit conditions that cannot be true for NULL values.\n- The query may include trivial `WHERE` conditions, such as constant expressions that do not impact the query results (e.g., \"OR 0=1\").", "transformations": "1. Convert `LEFT JOIN` to `INNER JOIN`: Since the `WHERE` clause conditions ensure that no null-complemented rows from the `LEFT JOIN` will be included in the final result, the `LEFT JOIN` operation can be safely converted to an `INNER JOIN`. This transformation hinges on the recognition that the `LEFT JOIN`'s potential to produce rows with NULL values in the columns from the joined table(s) is effectively nullified by the WHERE condition(s).\n2. Remove Trivial `WHERE` Conditions: Constant expressions in the `WHERE` clause that do not contribute to filtering the result set (e.g., \"OR 0=1\") should be removed. This step simplifies the query and potentially enables the database engine to optimize the execution plan further.\n3. Re-assess Additional Conversion Opportunities: After the initial transformations, additional optimizations may become apparent, especially in complex queries with multiple or nested joins. The simplified conditions could reveal further opportunities for converting other `LEFT JOIN` instances within the same query to `INNER JOIN` operations, reducing the overall complexity and potentially improving query performance."}
{"index": 9, "conditions": "- The SQL query involves searching for rows based on specific column values.\n- The columns used in the WHERE clause (for filtering) and/or SELECT clause (for data retrieval) are candidates for indexing.\n- The database does not already have a covering index that includes all the necessary columns required for the query.", "transformations": "1. Identify columns used in the WHERE and SELECT clauses of the query.\n2. Create a compound or covering index that includes:\n   - Columns used for filtering in the WHERE clause, in the order they appear or based on their selectivity.\n   - Columns used in the SELECT clause to retrieve data, ensuring the index can satisfy the query directly.\n3. Modify the query to ensure it can leverage the new index, if necessary. However, most modern SQL databases will automatically use the new index if it benefits the execution plan."}
{"index": 10, "conditions": "The SQL query utilizes traditional filtering mechanisms such as NOT EXISTS, NOT IN, EXISTS, IN, OR within JOINs and WHERE clauses.", "transformations": "- Replace IN with INTERSECT for querying intersecting datasets to potentially improve index usage and query speed.\n- Rewrite conditions using the OR operator into a series of UNION ALL operations to enhance code maintainability and performance.\n- Use EXCEPT instead of NOT IN or anti-joins to minimize duplicate row processing and optimize resource use, effectively reducing execution time."}
{"index": 11, "conditions": "The original query must contain a `RIGHT JOIN` clause between two or more tables, represented as `(T1, ...) RIGHT JOIN (T2, ...) ON P(T1, ..., T2, ...)`.", "transformations": "The `RIGHT JOIN` operation is converted to a `LEFT JOIN` operation by swapping the order of the tables involved in the join. The transformed query will be represented as `(T2, ...) LEFT JOIN (T1, ...) ON P(T1, ..., T2, ...)`. This transformation simplifies the processing of the query by utilizing a more commonly optimized and understood join operation."}
{"index": 12, "conditions": "The rule applies when there is an INNER JOIN operation between two tables (T1 and T2) with a predicate P that defines the join condition.", "transformations": "The INNER JOIN operation `T1 INNER JOIN T2 ON P(T1,T2)` is transformed to listing the tables as `T1, T2` in the FROM clause and including the join condition `P(T1,T2)` in the WHERE clause of the query."}
{"index": 13, "conditions": "- The query must contain a `GROUP BY` clause.\n- There is an available index that aligns with the search keys specified in the query.\n- Equality conditions on preceding or intervening columns in the index are present, which helps in bridging any \"gaps\" between the parts of the key utilized in the `GROUP BY` clause.\n- The query benefits from using indexes for selective key retrieval, especially when the `GROUP BY` clause does not match the initial part of the key or when it is segmented by gaps that constant equality conditions can close.", "transformations": "- A full or range index scan is selectively performed based on the conditions specified in the `WHERE` clause.\n- The query leverages the inherent order within indexes to avoid additional sorting steps required by the `GROUP BY` clause.\n- Comprehensive index prefixes are constructed by utilizing equality conditions to bridge gaps in index parts, thereby optimizing data retrieval efficiency.\n- The `GROUP BY` clause is optimized by employing indexes to fulfill grouped results efficiently, thereby enhancing overall query performance by avoiding unnecessary data sorting and retrieval operations."}
{"index": 14, "conditions": "1. The query involves GROUP BY operations.\n2. There is a possibility to filter data before these GROUP BY operations to reduce the volume of data.\n3. Specific conditions suitable for integration directly into the GROUP BY clause or as part of the WHERE clause exist.\n4. Subqueries are used, and there's an opportunity to apply filtering conditions closer to the data retrieval steps.\n5. The query utilizes inline SELECT statements for filtering after GROUP BY operations.", "transformations": "1. Apply filters in the WHERE clause before GROUP BY operations to decrease the amount of data to be aggregated.\n2. Integrate filtering conditions directly into the GROUP BY clause when applicable or ensure these conditions are part of the WHERE clause.\n3. Modify subqueries to include filter conditions, moving complex filters closer to the data retrieval steps and optimizing subquery performance.\n4. Avoid using inline SELECT statements for post-GROUP BY operation filtering. Instead, use condition pushdown to apply filtering as early as possible in the query execution."}
{"index": 15, "conditions": "- The SQL query performs a `GROUP BY` operation along with other operations like `JOIN`.\n- Query performance could be enhanced by reducing the size of intermediate datasets.\n- Suitable for queries involving large datasets or attributes from Entity-Attribute-Value (EAV) tables.\n- Applicable when reordering the sequence of operations can lead to performance improvements.", "transformations": "- Rearrange the query to perform `GROUP BY` operations at the earliest stage, ideally before executing operations like `JOIN`.\n- Utilize subqueries for pre-aggregation to reduce the dataset size early in the execution process.\n- Directly restructure the query to prioritize grouping operations to minimize the workload on subsequent operations like `JOIN`, thereby enhancing overall execution speed and efficiency."}
{"index": 16, "conditions": "The SQL query optimization rules apply under the following conditions:\n1. When the `LIMIT` clause is used to fetch a specified number of rows.\n2. When `ORDER BY` is used in conjunction with `LIMIT` to sort and limit the number of rows retrieved, particularly when sorting can leverage an index.\n3. When `DISTINCT` is used along with `LIMIT` to quickly identify and return unique rows without scanning the full dataset.\n4. During the use of `GROUP BY`, where optimization might involve sorting or traversing indexes in order to efficiently compute group values without processing the entire dataset.\n5. When sorting a specific number of rows from a single table based on non-indexed columns, utilizing in-memory sorting (`filesort`) techniques.", "transformations": "The specific SQL transformations that emerge from applying these optimization rules are:\n1. Combining `LIMIT` with `ORDER BY` encourages the database engine to stop the sorting process as soon as the required number of rows is obtained, avoiding full table sorts.\n2. Using `LIMIT` with `DISTINCT` leads to an early termination of the search for unique rows as soon as the needed amount is gathered, reducing time and resources spent on scanning the entire dataset.\n3. In the context of `GROUP BY`, optimizations may include indexing strategies or modifications to the way sorting is handled, such as employing `filesort` mechanisms that do not require temporary tables, ensuring that the database engine processes only the necessary data for group computations.\n4. Efficiencies are gained by encouraging the use of indexed columns with `ORDER BY` and `LIMIT`, making queries more efficient by reducing the cost associated with sorting and filtering operations."}
{"index": 17, "conditions": "1. The outer `WHERE` condition involves columns that are part of the `GROUP BY` clause.\n2. The query utilizes Common Table Expressions (CTEs) which can be transformed into inline subqueries.\n3. The query benefits from filtering before aggregation, for instance, using a specific filter such as a date range on a column that will be aggregated.", "transformations": "1. For condition pushdown optimization, rewrite the query to apply the `WHERE` condition directly in the derived table's `WHERE` clause if the condition is on `GROUP BY` columns. This reduces the rows before aggregation.\n2. For optimizing with CTE transformations, rewrite the CTEs into equivalent inline subqueries, especially where it allows for earlier condition application (for instance, applying a date range filter) before aggregation occurs. This can significantly narrow down the data to be processed."}
{"index": 18, "conditions": "The SQL query rewrite rule applies when a query uses `DISTINCT` to remove duplicates, especially in the presence of multiple columns and when `ORDER BY` is involved. Additionally, this rule is particularly relevant when the columns in the `DISTINCT` query are supported by indexes.", "transformations": "- Rewriting the query to replace `DISTINCT` with a `GROUP BY` clause on the same columns used in the `DISTINCT` operation. This can improve execution efficiency by potentially taking advantage of indexes on these columns more effectively.\n- Ensuring that indexes match the columns specified in the `DISTINCT` operations to facilitate more efficient query processing. This transformation aims to reduce the need for the creation of temporary tables and, in turn, speed up query execution."}
{"index": 19, "conditions": "The SQL query rewrite rule applies when there are:\n- Functions or operations (especially deterministic ones) within the SELECT, WHERE, JOIN conditions, or any part of the query that is executed multiple times for the same row.\n- The presence of potentially computationally expensive operations or function calls that are not dependent on the data of the specific row and thus can be optimized.", "transformations": "1. Move repeated function calls or operations outside of loops, if applicable. For example, if a function that generates a calculated value based on constants or parameters (not row-specific data) is being called in a loop, calculate the value once before the loop and store the result for reuse.\n   \n2. Replace inline functions in the SELECT or WHERE clause with a pre-calculated column if the function is deterministic and the input data does not change frequently. This might involve:\n   - Creating a temporary table that includes the results of the expensive function calls.\n   - Using a subquery or a Common Table Expression (CTE) that calculates the value once and then joins it with the main query.\n   \n3. When using aggregate functions that are called multiple times with the same parameters, consider storing the result in a variable or a temporary table, especially if the data set is large.\n\n4. Avoid using functions on indexed columns in the WHERE clause. This prevents the database from using the index efficiently. If a function must be used, consider creating a computed column that pre-calculates the function's result and index that column instead.\n\n5. If possible, simplify expressions and calculations to reduce their complexity and execution time. This might involve algebraic simplification or breaking down complex calculations into simpler parts that can be calculated separately and then combined.\n\nExample:\nOriginal Query:\n```sql\nSELECT id, name, expensive_function(column) as expensive_result\nFROM table\nWHERE expensive_function(column) > 100;\n```\n\nTransformed Query using a CTE:\n```sql\nWITH PreCalculated AS (\n  SELECT id, name, column, expensive_function(column) as expensive_result\n  FROM table\n)\nSELECT id, name, expensive_sel as expensive_result\nFROM PreCalculated\nWHERE expensive_result > 100;\n```"}
{"index": 20, "conditions": "1. The query makes use of the `ORDER BY` clause to sort the results.\n2. The columns specified in the `ORDER BY` clause are covered by an index or a subset of it is covered.\n3. Some parts of the indexed columns not used in the `ORDER BY` clause are referenced as constant values in the `WHERE` clause.", "transformations": "1. The database optimizer leverages indexes to fulfill the `ORDER BY` clause operations, even if the `ORDER BY` columns do not exactly match the indexed columns but are partially covered.\n2. If constant values are used in the `WHERE` clause for the non-referenced parts of the index, the optimizer can perform a range scan instead of a full table scan, utilizing the index efficiently for the sort operation.\n3. The optimization is applied both for ascending and descending order requirements, indicating the flexibility of indexes in sorting mechanisms under varying conditions.\n4. This technique minimizes the expense of explicit sorting operations, consequently speeding up the query response times by making optimal use of available indexes."}
{"index": 21, "conditions": "- The optimization rule applies when queries involve conditions checking if a column is `NULL` (`col_name IS NULL`).\n- It is particularly relevant when the column in question (`col_name`) is indexed.\n- The rule also applies to queries combining `IS NULL` checks with comparisons to constant values using `OR` (e.g., `col_name IS NULL OR col_name = const`).\n- When the column is part of a primary key and thereby implicitly `NOT NULL`, conditions checking for `NULL` can be optimized away.\n- The query involves redundancy by including `IS NULL` checks on columns that are defined as `NOT NULL`.\n- Use of the null-safe equal operator (`<=>`) in conjunction with `IS NULL` conditions and constant comparisons.", "transformations": "- Direct `IS NULL` queries on indexed columns are optimized to efficiently use the index.\n- Combined conditions involving `IS NULL` and constant value comparisons (`= const`) are optimized for more efficient evaluation, potentially leveraging indexes.\n- For primary key columns (implicitly `NOT NULL`), any `IS NULL` conditions are removed from the query, as they are unnecessary and can impair query performance.\n- Redundant `IS NULL` checks on columns defined as `NOT NULL` are eliminated from the query, reducing logical redundancies and simplifying the query logic.\n- Queries using `col_name IS NULL OR col_name = const` can be restructured for more efficient execution, utilizing indexes where appropriate and reducing unnecessary table scans.\n- Use of the null-safe equal operator (`<=>`) is optimized in context with `IS NULL` conditions and constant value checks, ensuring efficient query execution paths."}
{"index": 22, "conditions": "The SQL query rewrite rule applies when:\n1. The query employs multiple window functions that share the same `OVER` clause, specifically, identical partitioning and ordering specifications.\n2. The query's execution efficiency can be improved by consolidating the definition of identical windows to reduce redundancy in sorting and partitioning operations.", "transformations": "1. Introduce a `WINDOW` clause to define a common window by specifying the partitioning and ordering requirements shared among the window functions.\n2. Replace the `OVER` clauses of the window functions that share the same partitioning and ordering specifications with a reference to the newly defined window in the `WINDOW` clause.\n3. The optimizer then leverages the consolidated window definition, executing sorting and partitioning operations once for all referenced window functions, thereby reducing computational overhead and improving the overall query performance."}
{"index": 23, "conditions": "The rule applies when the original SQL query performs multiple scans or joins on the same table to retrieve different attributes for certain conditions, or when the query structure results in redundant data processing and complexity that could be reduced.", "transformations": "- Combine multiple joins into a single join operation by using `CASE` statements to conditionally select different attributes from the table in one pass. \n- Use the `COALESCE` function in conjunction with `CASE` statements to efficiently merge conditional attributes into distinct columns based on specific criteria without the need for additional joins.\n- Optimize the selection of conditional attributes by integrating `GROUP BY` with aggregate functions like `MAX` within `CASE` statements, thus condensing the result set to only the necessary data and avoiding needless retrieval and processing steps.\n- The overall transformation leads to a single, more efficient query that accomplishes the tasks of multiple, less efficient operations, improving performance, and simplifying the query for better readability and maintenance."}
{"index": 24, "conditions": "The SQL query contains nondeterministic functions within `WHERE` clauses or in other critical parts of the query where their presence could prevent efficient indexing and optimization.", "transformations": "1. Minimize the use of nondeterministic functions by calculating their values beforehand and storing these values in variables or using derived tables. This transforms nondeterministic function calls into a pseudo-deterministic context.\n2. Separate deterministic and nondeterministic conditions in queries, allowing the SQL optimizer to apply optimizations on the deterministic parts of the query. This can be achieved by structuring the query to isolate nondeterministic conditions in a manner that still allows for partial optimization.\n3. Utilize stored procedures and functions to encapsulate nondeterministic logic, improving manageability and potentially allowing for better optimization by pre-calculating nondeterministic values where possible, thus reducing their performance impact."}
{"index": 25, "conditions": "The SQL query contains constant expressions in conditions, including:\n- Constant expressions within logical conditions (e.g., `AND`, `OR`).\n- Redundant or tautological conditions.\n- The potential for early detection of invalid constant expressions that result in no rows being returned.\n- Use of constant values in range conditions, expressions involving columns of `const` or `system` tables, or results of uncorrelated subqueries.", "transformations": "- **Constant Folding:** Simplify constant expressions upfront, for example, transforming `(a<b AND b=c) AND a=5` into `b>5 AND b=c AND a=5`.\n- **Constant Condition Removal:** Eliminate redundant or tautological conditions, such as simplifying `(b>=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6)` to `b=5 OR b=6`.\n- **Efficient Usage of Indexes:** Evaluate constant expressions a singular time, improving the efficiency of indexed queries.\n- **Constant Propagation:** Convert nonconstant values in range conditions to constants, facilitating the use of indexes and improving the speed of queries.\n- **Early Detection of Invalid Expressions:** Quickly determine when `SELECT` statements based on constant expressions will return no rows, avoiding unnecessary executions."}
{"index": 26, "conditions": "1. **Out-of-Range Constant Handling**: The constant\u2019s value in a comparison exceeds or is below the column's data type limits.\n2. **Constant-Folding Optimization**: Comparisons involve constants and column values using comparison operators (e.g., `>`, `>=`, `<`, `<=`, `<>` / `!=`, `=`, `<=>`).\n3. **Range Boundary Folding**: A comparison constant is at the boundary of a column\u2019s data type range.\n4. **Handling for Decimal and Floating-Point Constants**: The condition involves `DECIMAL`, `REAL`, `DOUBLE`, or `FLOAT` data types, where optimizations account for overflows, precision matching, and simplified comparisons due to overflow or boundary conditions.\n5. **Early Detection of Invalid Constant Expressions**: The query involves constant expressions that can be evaluated early to determine if the `SELECT` statement will return any rows.", "transformations": "1. **Out-of-Range Constant Handling**:\n   - If the constant exceeds the range, the comparison may be transformed to a `FALSE` condition or a `TRUE` condition for a `NOT` comparison, effectively removing or simplifying the `WHERE` clause.\n   - If the constant value does not overlap with the column data type range, the query could be simplified to `WHERE FALSE` or to check for `NOT NULL` if it's a negated condition.\n\n2. **Constant-Folding Optimization**:\n   - Simplifies comparisons by applying the comparison during the query optimization phase, thus avoiding the comparison at runtime.\n   - Optimizations like evaluating `COLUMN = CONSTANT` during planning can reduce the processing workload during execution.\n\n3. **Range Boundary Folding**:\n   - Comparisons using `>=`, `<=` at the datatype's extreme values could be converted to `=` when the constant matches the boundary, reducing the complexity of the condition.\n\n4. **Handling for Decimal and Floating-Point Constants**:\n   - Overflows are handled by either discarding the condition or converting it to a simpler form that reflects the overflow situation, such as converting a condition that would always be true or false based on the comparison.\n   - Precision adjustments ensure that comparisons involving floating-point types do not suffer from precision errors by potentially adjusting the comparison operator or the precision of the constants involved.\n\n5. **Early Detection of Invalid Constant Expressions**:\n   - If an invalid constant expression is determined during query optimization (e.g., division by zero, out-of-range value), the optimizer can conclude that no rows will satisfy the condition, potentially rewriting the query to a no-operation or a simple return without accessing tables."}
{"index": 27, "conditions": "- The query involves the use of MIN() or MAX() functions.\n- The column under the MIN() or MAX() function is indexed.\n- The column under MIN() or MAX() functions is preceded by constants or involved in conditions that can be evaluated as constants.", "transformations": "- The SQL engine performs a quick key lookup on the indexed column specified within the MIN() or MAX() function.\n- Substitute the operation involving MIN() or MAX() on the indexed column with a constant value derived from the index, if possible.\n- This transformation streamlines the query by reducing it to a simpler form where the expensive MIN() or MAX() computation is replaced with a direct value retrieval, thus enhancing the query's performance significantly."}
{"index": 28, "conditions": "The SQL query rewrite rule of *Derived Condition Pushdown* applies when:\n1. The outer query conditions can be moved into subqueries without affecting the result.\n2. Derived tables do not involve aggregation or window functions, making it possible to directly apply conditions into the subquery.\n3. When derived tables involve aggregate functions, conditions not on `GROUP BY` columns are present. These can be optimized into a `HAVING` clause.\n4. A mix of conditions exists\u2014some related to `GROUP BY` columns and others not\u2014requiring a split into `WHERE` and `HAVING` clauses respectively.\n5. Excessive selection criteria can help leverage database indexes more effectively and reduce join sizes by pre-selecting records.\n6. The strategy requires applying the most restrictive selection criteria as early as possible in the query execution.", "transformations": "1. Move outer query conditions into the WHERE clause of subqueries when these conditions do not affect aggregations or window functions.\n2. Conditions in the outer query not involving `GROUP BY` columns of a derived table with aggregation are transformed into the `HAVING` clause of the subquery.\n3. For mixed conditions involving `GROUP BY` columns:\n   - Conditions related to `GROUP BY` columns are included in the WHERE clause of the subquery.\n   - Conditions not related to `GROUP BY` columns are placed in the `HAVING` clause.\n4. Intentionally incorporate excessive selection criteria into subqueries or at initial stages of the main query to utilize indexes and minimize join operation sizes.\n5. Apply the most restrictive conditions early in the query, such as at the initial data selection phase, to reduce the dataset size before executing joins and more complex operations."}
{"index": 29, "conditions": "The rule applies when there is a use of `IN` or `=ANY` comparison involving a subquery. It is also applicable for scenarios dealing with composite keys or multiple columns, and there is a consideration for handling `NULL` values in subqueries to maintain logical integrity.", "transformations": "1. Convert `outer_expr IN (SELECT inner_expr FROM ... WHERE subquery_where)` into an equivalent `EXISTS` query, adding an `AND outer_expr=inner_expr` condition within the subquery's `WHERE` clause. This narrows down the rows the database needs to evaluate.\n2. For composite keys or conditions involving multiple columns, expand the added equality condition to include comparisons for all relevant columns, i.e., `AND outer_col1=inner_col1 AND outer_col2=inner_col2 AND ...`.\n3. Include conditions to handle `NULL` values appropriately, ensuring the query accounts for scenarios where `inner_expr` might be `NULL`. This can involve adding conditions like `OR inner_expr IS NULL` within the subquery to ensure the integrity and completeness of the logic."}
