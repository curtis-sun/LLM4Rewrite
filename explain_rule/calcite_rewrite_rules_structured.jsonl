{"name": "SORT_UNION_TRANSPOSE_MATCH_NULL_FETCH", "rewrite_rules_structured": [{"conditions": "1. A SQL query performs a `UNION ALL` operation on multiple select statements.\n2. Following the `UNION ALL`, there's an `ORDER BY` clause intending to sort the results, with no `OFFSET` clause present in the query.\n3. Each select statement involved in the `UNION ALL` could potentially benefit from pre-application of the order defined by the `ORDER BY` clause, without violating the intended sort order across the combined result set.", "transformations": "1. Identify the `ORDER BY` clause following a `UNION ALL` that combines multiple select statements and verify there's no associated `OFFSET` directive.\n2. For each select statement involved in the `UNION ALL`:\n   - Apply the `ORDER BY` clause directly to the select statement if doing so does not change the intended order of the final result set. This effectively means prepending an `ORDER BY` to each select statement based on the `ORDER BY` clause initially following the `UNION ALL` operation.\n3. Retain the original `ORDER BY` clause following the `UNION ALL`. This ensures that the final result set is ordered as intended, taking into account that individual select statements are now pre-sorted.\n4. Implement this transformation only if it's determined that sorting individual select statements before the `UNION ALL` would maintain the overall desired sort order and is expected to either improve performance by reducing sorting overhead or have no negative impact."}]}
{"name": "PROJECT_CORRELATE_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "This rule applies to SQL queries where a projection (SELECT clause) is applied on top of a correlated subquery. Specifically, the correlated subquery is typically found in the WHERE clause, JOIN condition, or FROM clause using EXISTS, IN, or a JOIN with a non-standard condition referencing columns from the outer query. Additionally, the SELECT clause (projection) should not contain window functions, as they are instances where this optimization cannot apply directly.", "transformations": "- Identify Referenced Columns: Examine the SELECT clause to identify columns and expressions referenced. Determine whether these columns originate from the outer query, the inner (correlated) subquery, or both.\n- Pushing Projections Down: For columns and expressions solely originating from the inner or outer part of the correlation, modify the correlated subquery and/or the outer query to include only necessary columns in their SELECT clauses. This can be done by creating sub-selects (nested SELECT statements) that project only the referenced columns.\n- Adjusting Correlations: If the projections modify how columns are referenced, ensure that the correlation condition in the WHERE clause of the subquery or in the ON condition of a JOIN still correctly references the modified column list.\n- Re-creating the Project and Correlate in SQL: Construct a new SQL query that reflects these changes. The outer query's SELECT clause may need adjustments to align with the new structure of the transformed subquery or JOIN condition. Ensure that aliasing is correctly handled to maintain the semantic equivalence."}]}
{"name": "FILTER_MERGE", "rewrite_rules_structured": [{"conditions": "1. Two SQL SELECT queries are nested, or one is directly dependent on the other through subquery fashion or consecutive WHERE conditions applied on the same dataset.\n2. Both SELECT queries apply filtering conditions using the WHERE clause.", "transformations": "- Identify the nested SQL queries or consecutive WHERE clauses that are acting as filters on the same data.\n- Extract the conditions specified in both WHERE clauses.\n- Merge these conditions using a logical AND connector.\n- Rewrite the SQL query to include a single SELECT query with a single WHERE clause that includes the combined condition."}]}
{"name": "JOIN_ADD_REDUNDANT_SEMI_JOIN", "rewrite_rules_structured": [{"conditions": "1. The SQL query involves an INNER JOIN operation between two tables or views, referred to as `X` and `Y`.\n2. The join hasn't been subject to a similar transformation previously (e.g., it doesn't already involve a semi-join operation in the place of `X` or `Y`).\n3. There exists a valid JOIN condition for the operation which specifies how `X` and `Y` are to be linked.", "transformations": "- Given an original SQL query structured as follows:\n\n  ```sql\n  SELECT ... FROM X INNER JOIN Y ON X.key = Y.key ...\n  ```\n\n  Transform the query by introducing a semi-join. The transformation doesn't directly translate to standard SQL syntax as most SQL databases do not explicitly support semi-join as a distinct operation. Instead, we model the intended effect using a subquery in the WHERE clause or a JOIN with a sub upquery, ensuring that `X` is filtered to only include rows that have a corresponding match in `Y` before performing the original join. Therefore, the rewritten query could look like this:\n\n  ```sql\n  SELECT ... FROM X INNER JOIN Y ON X.key = Y.key WHERE X.key IN (SELECT Y.key FROM Y)\n  ```\n\n  Alternatively, using an explicit inner join with a subquery might look like:\n\n  ```sql\n  SELECT ... FROM (SELECT X.* FROM X WHERE EXISTS (SELECT 1 FROM Y WHERE Y.key = X.key)) AS X_filtered INNER JOIN Y ON X_filtered.key = Y.key\n  ```\n\n- In these transformations, `Y` remains as the right input of the join operation. The semi-join (modeled by a subquery filtering `X` based on the existence of matching records in `Y`) effectively becomes the new \"left\" input in a logical sense, although physically represented in a different manner within the SQL language.\n\n**Note:**\nThe specific approach to emulate a semi-join in SQL depends on the database system's capabilities and might require adjustments if EXISTS or IN subqueries are not optimally supported. The goal is to reduce the computational overhead of the join operation by filtering `X` to only those records with at least one match in `Y` before performing the original inner join."}]}
{"name": "AGGREGATE_EXPAND_DISTINCT_AGGREGATES", "rewrite_rules_structured": [{"conditions": "For SQL queries containing aggregates like `COUNT(DISTINCT x)`, `SUM(DISTINCT x)`, `MIN(DISTINCT x)`, and `MAX(DISTINCT x)` all operating over the same column `x`", "transformations": "rewrite the original query to a single `GROUP BY x` including all relevant aggregate functions in the `SELECT` clause but remove the `DISTINCT` keyword from within those aggregates."}, {"conditions": "When an SQL query involves both distinct and non-distinct aggregates or distinct aggregates with different arguments", "transformations": "split the query into separate `GROUP BY` clauses for each unique set of arguments. For distinct and non-distinct aggregates, you may need a full outer join to combine their results based on the original grouping columns."}, {"conditions": "For cases with distinct aggregates over different columns and no straightforward optimization is possible", "transformations": "perform separate `GROUP BY` operations for each distinct column needed in the aggregates, and join these results together to provide the being final result set."}]}
{"name": "AGGREGATE_UNION_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "1. The SQL query contains an aggregate function (e.g., `SUM()`, `COUNT()`) applied after a `UNION ALL` operation. \n2. The `UNION ALL` operation does not inherently ensure uniqueness across its inputs that would affect the correctness of aggregate functions if they were pushed down (validation of this condition might require schema or data analysis beyond simple SQL transformation logic).", "transformations": "1. **Validation:** Ensure the SQL query involves a `UNION ALL` directly followed by an aggregate operation, and that pushing down the aggregate will not change the semantics of the query incorrectly (e.g., aggregating over unique rows that become non-unique after the `UNION ALL`). \n2. **Transforming Aggregate Functions:** For aggregate functions like `COUNT()`, modify them to ensure their correctness when applied after `UNION ALL`. This often involves changing `COUNT()` to `SUM()` around an indicator for non-null rows if `COUNT()` is used. \n3. **Applying Transformation:** \n- Identify each select query (or subquery) involved in the `UNION ALL` operation. \n- Apply an aggregate operation similar to the original operation directly within each of these subqueries. This might involve wrapping each subquery in an additional `SELECT` statement that performs the aggregations. \n- Use `UNION ALL` to combine these newly aggregated subqueries. \n- Apply a final aggregate operation on top of the combined results. This operation should ensure overall query semantics remain unchanged, particularly regarding group by keys, which might require adjustments to match the aggregated data's new structure. \n\n- **Example Transformation:** For a query that originally looks like: \n```sql \nSELECT COUNT(*) FROM ( \n  SELECT column1 FROM table1 \n  UNION ALL \n  SELECT column1 FROM table2 \n) subquery \n``` \nTransform it into: \n```sql \nSELECT SUM(subquery_count) FROM ( \n  SELECT COUNT(*) as subquery_count FROM table1 \n  UNION ALL \n  SELECT COUNT(*) as subquery_count FROM table2 \n) subquery \n``` \nThis corrects the usage of `COUNT()` by switching to a `SUM()` of counts from each part of the union, assuming `COUNT()` semantics are desired across the `UNION ALL`."}]}
{"name": "JOIN_CONDITION_PUSH", "rewrite_rules_structured": [{"conditions": "For an INNER JOIN operation in SQL, if any condition in the WHERE clause only references columns from one table and not the other, and if this condition does not involve the columns used in the ON clause", "transformations": "you can move this condition into the ON clause of the INNER JOIN, or apply the condition directly in a subquery of the JOINed table. If the filter involves columns from both tables, ensure it remains in the WHERE clause."}, {"conditions": "For LEFT, RIGHT, or FULL OUTER JOIN operations, if a condition in the WHERE clause or above the JOIN operation can be applied directly to the preserved side without changing the result (meaning it doesn't exclude non-matching rows that should be null-extended by the join)", "transformations": "you can move this condition into the ON clause. If a filter on the non-preserved side could potentially eliminate all rows from that side - turning the OUTER JOIN effectively into an INNER JOIN - evaluate and apply the condition accordingly, either before the join, in the join's ON clause with caution, or after the join in the WHERE clause, depending on the exact semantics needed."}, {"conditions": "When a SQL query involves NULL checks (e.g., IS NULL or IS NOT NULL conditions) related to columns being JOINed", "transformations": "these conditions should be optimized based on their logical implications on the join result. For instance, a filter condition involving an IS NOT NULL check on a column from the non-preserved side of an OUTER JOIN should be considered carefully to see if it affects the logical outcome of the join. Apply these NULL checks directly in the JOIN condition if they preserve the intended semantics, or place them after the join in the WHERE clause to filter out undesired rows."}, {"conditions": "In SQL, when the query's WHERE conditions or the existing JOIN conditions logically imply additional conditions - for example, through transitive relationships or domain-specific knowledge that can infer other constraints", "transformations": "these inferred conditions should be added into the JOIN's ON clause to minimize the cartesian product size by excluding irrelevant data early. This is particularly relevant when connecting tables with complex relationships or when multiple filters applied together suggest a stricter join condition."}]}
{"name": "SORT_REMOVE_CONSTANT_KEYS", "rewrite_rules_structured": [{"conditions": "1. The SQL query includes an `ORDER BY` clause where all columns specified are based on constant expressions or literal values.\n2. The query does not include `LIMIT` or `OFFSET` clauses, indicating there are no pagination requirements.", "transformations": "1. Detect constant expressions in the `ORDER BY` clause.\n2. If all expressions in the `ORDER BY` clause are constants, remove the `ORDER BY` clause entirely from the query.\n3. Ensure that no `LIMIT` or `OFFSET` clauses are present. If they are present, this rule does not apply."}, {"conditions": "1. The SQL query includes an `ORDER BY` clause with a mix of constant expressions or literal values and non-constant column references.", "transformations": "1. Identify which parts of the `ORDER` clause are based on constant expressions or literals and which are based on non-constant column references.\n2. Remove the constant expressions or literals from the `ORDER BY` clause, keeping only the non-constant column references.\n3. Rewrite the `ORDER BY` clause without the constant sort keys."}]}
{"name": "AGGREGATE_JOIN_REMOVE", "rewrite_rules_structured": [{"conditions": "For a SQL query where you have a `GROUP BY` operation applied right after a `LEFT JOIN` operation, and in the `SELECT` clause of the aggregation, columns from the right side of the join are not used (or only used in functions with the `DISTINCT` modifier)", "transformations": "Rewrite the query to remove the `LEFT JOIN`. Adjust the `FROM` clause to directly use the left-side table, and adjust the `SELECT` and `GROUP BY` clauses accordingly if they referred to any columns from the right side that might no longer be needed or available."}, {"conditions": "For a SQL query that performs a `GROUP BY` operation after a `RIGHT JOIN`, and aggregate functions in the `SELECT` clause do not use columns from the left side of the join (or only use them in functions with the `DISTINCT` modifier)", "transformations": "The query can be rewritten to remove the `RIGHT JOIN`. Replace the `FROM` with the right-side table and adjust the `SELECT` and `GROUP BY` clauses as necessary to exclude or modify references to the left-side table's columns."}]}
{"name": "AGGREGATE_PROJECT_MERGE", "rewrite_rules_structured": [{"conditions": "- The SQL query contains a `GROUP BY` clause that groups by simple columns (no expressions in the `GROUP BY` list).\n- The aggregate functions in the `SELECT` clause operate directly on columns (no expressions inside the aggregate functions).\n- The `SELECT` clause only contains the columns used in the `GROUP BY` clause and the aggregates without any transformations or additional expressions.", "transformations": "- Directly apply the `GROUP BY` and aggregate functions to the data source referred to in the `FROM` clause of the inner query before the projection.\n- Eliminate the outer projection layer if it only renames the columns without transforming them."}, {"conditions": "- The `SELECT` clause of an outer query precisely matches the columns used in the `GROUP BY` and aggregate functions of an inner query, without any column transformations or renamings.\n- The inner `SELECT` only serves as a passthrough for these columns.", "transformations": "- Remove the inner `SELECT` layer, directly applying the aggregate functions and `GROUP BY` to the original data source."}]}
{"name": "PROJECT_WINDOW_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "Window functions are used (`OVER` clause is present) inside the SELECT statement.\n- Not all columns from the tables in the FROM clause are used in the SELECT list and window functions.", "transformations": "1. Identify columns directly used in the SELECT list and inside window function specifications (PARTITION BY, ORDER BY).\n2. Create a subquery (or CTE) to select only identified required columns from the original tables.\n3. Replace the original table references with the subquery (or CTE), ensuring window functions operate on a reduced dataset."}, {"conditions": "If a window function is used and certain columns are only needed for window function computation or the final SELECT projection, introduce an optimized subquery (or CTE) that selects these columns before applying the window function. This can enhance performance by minimizing the working dataset early.", "transformations": "1. Create a subquery (or CTE) that selects necessary columns for the window function and final projection from the original table(s).\n2. Apply the window function on this subquery (or CTE) result, ensuring the window function operates on a minimal set of columns."}, {"conditions": "After applying window functions with an optimized column set, review the final SELECT projection. If the projection merely renames columns without applying any transformation (e.g., SELECT a AS b from...), and if these transformations are redundant or trivial, simplify the SELECT list by removing unnecessary column aliasing or computations.", "transformations": "1. Inspect the final SELECT list after applying window functions. Identify if the projection merely renames columns or performs trivial transformations.\n2. Simplify the SELECT list by removing unnecessary aliasing, keeping the query semantically equivalent but structurally simpler.\n3. If a subquery (or CTE) was used for column optimization, and if the final SELECT is now simplified to direct column references, evaluate if merging the subquery (or CTE) output directly into the main SELECT could further simplify the query."}]}
{"name": "FILTER_VALUES_MERGE", "rewrite_rules_structured": [{"conditions": "1. The SQL query includes a `WHERE` clause that applies a filter condition directly following a `VALUES` clause creating a derived table (often used with `IN` or similar conditions).\n2. The `VALUES` clause specifies a set of literal tuples. This does not include `VALUES` clauses that are dynamically generated or empty.\n3. If the SQL query uses columns created on-the-fly in the `VALUES` clause, and those columns are manipulated or filtered in the subsequent `WHERE` clause, then this rule can be applied.", "transformations": "- Extract the filter conditions from the `WHERE` clause that directly operates on the tuples specified in the `VALUES` clause.\n- Evaluate the filter condition for each tuple inside the `VALUES` clause. If a tuple does not satisfy the condition, it is removed from the result set.\n- If the `WHERE` clause includes transformations or selections on specific columns from the `VALUES` (like changing values, selecting a subset of columns, or applying functions), implement these transformations within the `VALUES` clause itself to create a new set of tuples that already reflects the desired output."}]}
{"name": "FILTER_SET_OP_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "This rule applies when a SQL query contains a filtering condition (`WHERE` clause) directly after a set operation (`UNION`, `INTERSEKCT`, `EXCEPT`). The set operation must combine results from two or more queries.", "transformations": "\n1. **Identify the Filtering Condition**: Recognize the condition placed in the `WHERE` clause that affects the result set of a set operation.\n2. **Adjust the Filter Conditions for Each Input Query**: For each branch (sub-query) involved in the set operation, adjust the filtering condition to correctly reference the columns within that sub-query. This might require renaming columns or modifying conditions to match the schema and data context of each input query.\n3. **Apply Filter Conditions Directly in Input Queries**: Rewrite each input query of the set operation to include the adjusted filter condition. This is achieved by incorporating a `WHERE` clause in each sub-query if not present already, or adding the condition to an existing `WHERE` clause using `AND`.\n4. **Reconstruct the Set Operation**: Use the modified input queries as the new inputs for the set operation (`UNION`, `INTERSECT`, `EXCEPT`). The set operation now combines the results of the filtered inputs.\n5. **Example Transformation**:\n    - Original Query:\n      ```sql\n      SELECT * FROM (\n          SELECT a, b FROM Table1\n          UNION\n          SELECT a, b FROM Table2\n      ) AS Combined\n      WHERE a > 5;\n      ```\n    - Transformed Query:\n      ```sql\n      SELECT a, b FROM (SELECT a, b FROM Table1 WHERE a > 5) AS Filtered1\n      UNION\n      SELECT a, b FROM (SELECT a, b FROM Table2 WHERE a > 5) AS Filtered2;\n      ```\n"}]}
{"name": "JOIN_PROJECT_BOTH_TRANSPOSE_INCLUDE_OUTER", "rewrite_rules_structured": [{"conditions": "When an SQL query performs an INNER JOIN between two tables or subqueries, and both sides of the join have a SELECT clause that projects certain columns directly before the join.", "transformations": "1. Identify the columns projected on both sides of the INNER JOIN.\n2. Adjust the INNER JOIN's ON condition to match the column aliases provided in the projections, if necessary.\n3. Move the projection (SELECT clause) above the JOIN, combining both side's columns into a single SELECT clause immediately preceding the INNER JOIN.\n4. Ensure that the final SELECT projection after rearrangement matches the original output column list and order."}, {"conditions": "When an SQL query performs a LEFT, RIGHT, or FULL OUTER JOIN between two subqueries or tables and both sides have a SELECT clause projecting specific columns. Additionally, the projection should not introduce NULL values in the result set which are not a result of the outer join mechanism.", "transformations": "1. Examine both sides of the OUTER JOIN to confirm that the projections do not introduce unintended NULLs for outer rows.\n2. Adjust the OUTER JOIN's ON condition to use the column aliases from the projections, if needed.\n3. Move the SELECT projection to above the JOIN, ensuring columns from both sides are included in a single SELECT clause placed immediately before the OUTER JOIN.\n4. If the join was an OUTER JOIN, additional care must be taken to ensure null compatibility and semantics are preserved, potentially adjusting the SELECT list to include explicit casting or CASE expressions to maintain nullability."}]}
{"name": "AGGREGATE_MERGE", "rewrite_rules_structured": [{"conditions": "The group key columns of the outer query's `GROUP BY` are a subset of the group key columns of the inner query's `GROUP BY`. Both the inner and outer queries use aggregate functions that can be expressed as rollups (i.e., functions that compute totals in a hierarchical manner, such as SUM, MIN, MAX), excluding more complex or non-mergeable functions like AVG or DISTINCT COUNT. The aggregate functions in the outer query do not semantically alter the result of aggregate functions in the inner query, allowing for direct mathematical or logical consolidation.", "transformations": "Combine the two `GROUP BY` operations into a single `GROUP BY` that retains the more extensive set of group key columns (from the bottom `GROUP BY`, assuming the top's keys are a subset) and adapts the aggregate functions according to merge-compatible operations. This step simplifies the query by reducing it to a structure that performs the aggregation in a single step, thereby optimizing execution."}, {"conditions": "The SQL query meets the initial condition of nested `GROUP BY` operations with the outer group keys being a subset of the inner, but involves aggregate functions like AVG of AVGs or COUNT of COUNTs.", "transformations": "Maintain the nested `GROUP BY` structure without attempting to simplify further. This ensures the accuracy and integrity of the aggregated data, acknowledging that some optimization strategies might not be viable for all function combinations due to inherent aggregation logic complexities."}]}
{"name": "AGGREGATE_UNION_AGGREGATE_FIRST", "rewrite_rules_structured": [{"conditions": "1. Presence of a `UNION ALL` Operation: There must be a `UNION ALL` operation combining the results of two select queries. This rule does not apply to plain `UNION` operations that imply deduplication.\n2. Use of `GROUP BY` in both Queries without Aggregate Functions: Both select queries involved in the `UNION ALL` must use `GROUP BY` clauses and do not contain aggregate functions (e.g., `SUM`, `COUNT`, `AVG`, etc.) in their select list. The purpose of the `GROUP BY` in this context is primarily for deduplication rather than aggregation.", "transformations": "1. Combine Queries with `UNION ALL` Without Initial `GROUP BY`: Remove the `GROUP BY` clauses from both select queries involved in the `UNION ALL`. Combine these queries using `UNION ALL` as originally specified.\n2. Apply a Single `GROUP BY` After the Union: Apply a single `GROUP BY` clause after the `UNION ALL` operation. This `GROUP BY` clause should include all columns from the select lists of the original queries. This effectively deduplicates the combined result set in one operation."}]}
{"name": "SORT_UNION_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "The original query must include a `UNION ALL` statement. The `ORDER BY` clause must include a `LIMIT` but no `OFFSET`.", "transformations": "Adding the `ORDER BY` clause with the same sort specifications and the `LIMIT` to each SELECT statement participating in the `UNION ALL`."}, {"conditions": "Only if at least one of the queries within the `UNION ALL` had the `ORDER BY` and `LIMIT` successfully applied.", "transformations": "Ensure to apply an additional `ORDER BY` with the same original sorting conditions and `LIMIT` on the entire `UNION ALL` result."}]}
{"name": "AGGREGATE_JOIN_JOIN_REMOVE", "rewrite_rules_structured": [{"conditions": "The aggregate function(s) in the SELECT clause does not solely rely on columns brought in by the \"inner-most\" left join. Distinct aggregate functions are used, ensuring that removing the join does not alter the result set. The ON condition of the subsequent JOIN (the top JOIN in the original rule) does not utilize columns exclusive to the redundant left join table or derived table. The key columns for joining across both the redundant left join and the subsequent join (top join) are identical, ensuring the resulting join condition integrity remains unaffected post-optimization.", "transformations": "Remove or skip the FROM clause sub-query or table reference that represents the redundant left join. Rewrite the JOIN condition of the subsequent JOIN to directly relate the table or derived table on the right side of the redundant left join to the next subsequent table or derived table in the FROM clause. Adjust the GROUP BY and SELECT clauses, if necessary, to reflect the change in available columns due to the removal of the redundant join. This includes ensuring that any column references from the removed join are replaced or removed as appropriate, while maintaining the original GROUP BY semantics without the columns from the removed join. \n**Before Optimization**:\n```sql\nSELECT AGG_FUNCTION(table2.column) -- AGG_FUNCTION could be SUM, COUNT, etc.\nFROM table1\nLEFT JOIN (table2 LEFT JOIN table3 ON table2.key = table3.key) ON table1.key = table2.key\nGROUP BY table1.column;\n```\n\n**After Optimization**:\n```sql\nSELECT AGG_FUNCTION(table2.column)\nFROM table1\nJOIN table3 ON table1.key = table3.key -- Assuming table2 is redundant\nGROUP BY table1.to_column;\n```"}]}
{"name": "PROJECT_SUB_QUERY_TO_CORRELATE", "rewrite_rules_structured": [{"conditions": "This rule applies when a scalar sub-query is present in the SELECT list of a SQL query. A scalar sub-query is characterized by returning a single value (i.e., one column and one row). It is usually evaluated for each row of the query it's part of.", "transformations": "The scalar sub-query is transformed into a join (LEFT JOIN if the sub-query is correlated) with an aggregate function applied to the joined table. The transformed query projects the result of the aggregate function instead of the scalar sub-query."}, {"conditions": "This rule applies when a query contains sub-queries that construct collections (ARRAY, MAP, MULTISET) and could be correlated to the outer query.", "transformations": "The sub-query is transformed into a series of JOIN operations followed by the application of a COLLECT aggregate function to construct the required collection in the outer query's SELECT list. This transformation ensures that the collection constructor is efficiently executed as part of a join operation."}, {"conditions": "This applies to queries utilizing IN, EXISTS, SOME/ANY, or UNIQUE sub-queries within their WHERE clause, potentially correlated to an outer query.", "transformations": "For IN and EXISTS Sub-queries: These are converted into equivalent INNER JOINs or LEFT JOINs (for correlation) with the outer query, including conditions moved to ON or WHERE clauses that replicate the sub-query logic. For EXISTS Sub-queries: Transformed into a JOIN (typically LEFT JOIN for correlation) and checking for non-null values in the joined table to replicate EXISTS logic. For SOME/ANY and UNIQUE Sub-queries: Given their more specific nature and less common usage, these transformations depend greatly on the DBMS's SQL dialects and may involve CASE statements or distinct JOIN and WHERE clause constructions to ensure the semantics are preserved after transformation."}]}
{"name": "AGGREGATE_REDUCE_FUNCTIONS", "rewrite_rules_structured": [{"conditions": "any SELECT statement or subquery using the AVG aggregate function", "transformations": "AVG(x) as SUM(x) / COUNT(x)"}, {"conditions": "computing the population standard deviation", "transformations": "STDDEV_POP(x) as the square root of (`SUM(x^2) - SUM(x)^2 / COUNT(x)`) / COUNT(x)"}, {"conditions": "for the sample standard deviation computation", "transformations": "STDDEV_SAMP(x) as the square root of (`SUM(x^2) - SUM(x)^2 / COUNT(x)`) / (COUNT(x) - 1)"}, {"conditions": "for the population variance computation", "transformations": "VAR_POP(x) as (`SUM(x^2) - SUM(x)^2 / COUNT(x)`) / COUNT(x)"}, {"conditions": "for the sample variance computation", "transformations": "VAR_SAMP(x) as (`SUM(x^2) - SUM(x)^2 / COUNT(x)`) / (COUNT(x) - 1)"}, {"conditions": "to compute population covariance", "transformations": "COVAR_POP(x, y) by applying a formula involving SUM and COUNT"}, {"conditions": "using a formula for sample covariance", "transformations": "COVAR_SAMP(x, y) using a formula involving SUM, COUNT, and an adjustment for sample calculations"}, {"conditions": "for transforming REGR_SXX(x, y) and REGR_SYY(x, y)", "transformations": "into expressions involving the computation of VAR_POP(x) or VAR_POP(y) respectively, multiplied by REGR_COUNT(x, y)"}]}
{"name": "AGGREGATE_VALUES", "rewrite_rules_structured": [{"conditions": "In an SQL query, when a `GROUP BY` clause is present alongside aggregate functions (`COUNT`, `SUM`) in the `SELECT` clause, and it is known that the dataset or table being aggregated is empty (for instance, filtering conditions in the `WHERE` clause that are known to exclude all rows)", "transformations": "directly replace the call to these aggregate functions with the literal `0` in the result set, without needing to execute the aggregate operation on the dataset."}, {"conditions": "In an SQL query, when a `GROUP BY` clause is used with aggregate functions such as `MIN`, `MAX`, or `SUM` in the `SELECT` clause, and it is determined that the dataset or table being aggregated is bound to be empty (due to, for example, a `WHERE` clause that filters out all rows)", "transformations": "directly replace the call to these aggregate functions with the keyword `NULL` in the result set, sidestepping the need to perform any aggregate operation on the data."}]}
{"name": "AGGREGATE_REMOVE", "rewrite_rules_structured": [{"conditions": "The SQL query performs a `GROUP BY` on all columns in the `SELECT` clause without any aggregate functions being used. The underlying table or subquery in the `FROM` clause provides a distinct set of rows based on the columns used in the `GROUP BY` clause.", "transformations": "Remove the `GROUP JOIN` clause entirely. Ensure the `SELECT` clause continues to list the same columns, effectively transforming `SELECT DISTINCT column(s) FROM table GROUP BY column(s)` to `SELECT DISTINCT column(s) FROM table`."}, {"conditions": "The SQL query includes a `GROUP BY` clause with one or more aggregate functions. Each aggregate function used in the `SELECT` clause must be identifiable as splittable (e.g., `SUM`, `COUNT`). The data input to the `GROUP BY` (from the `FROM` clause or an inner subquery) must already be distinct or made distinct through a `SELECT DISTINCT` or equivalent operation.", "transformations": "For each splittable aggregate function: If a direct calculation or substitution based on the distinct nature of the input is possible, modify the select expression accordingly. For example, replace `SUM(column)` with `column` if each `column` value is unique. If the `GROUP BY` is no longer necessary (all aggregate functions have been addressed), remove the `GROUP BY` clause. Adjust the `SELECT` clause as needed to match the expected output without the `GROUP BY` construct."}]}
{"name": "SEMI_JOIN_JOIN_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "A semi-join (expressed as an EXISTS clause or IN clause, depending on the SQL database) follows a `JOIN` operation. The semi-join's condition only references columns from the left table in the `JOIN`.", "transformations": "1. Identify the `SELECT...FROM...JOIN...WHERE` structure where the `WHERE` clause contains the semi-join condition.\n2. Move the semi-join condition into a subquery that is from the left table and modify the `SELECT` clause to include this subquery.\n3. Ensure the semi-join (subquery) in the `FROM` clause is joined back to the right table of the original join operation.\n4. Rewrite the query by including the semi-join explicitly with an `ON` clause for the condition and adjusting the `SELECT` list as needed.\n\nExample SQL transformation:\n-- Before transformation\nSELECT X.* FROM X\nJOIN Y ON X.id = Y.X_id\nWHERE X.id IN (SELECT Z.X_id FROM Z WHERE Z.condition = 'value');\n\n-- After transformation\nSELECT X.* FROM (SELECT X.* FROM X WHERE X.id IN (SELECT Z.X_id FROM Z WHERE Z.condition = 'value')) AS X\nJOIN Y ON X.id = Y.X_id;"}, {"conditions": "A semi-join follows a `JOIN` operation. The semi-join's condition only references columns from the right table in the `JOIN`.", "transformations": "1. Identify the `SELECT...FROM...JOIN...WHERE` structure where the `WHERE` clause contains the semi-join condition.\n2. Move the semi-join condition into a subquery that is from the right table and modify the `SELECT` clause to include this subquery.\n3. Ensure the semi-join (subquery) in the `FROM` clause is joined back to the left table of the original join operation.\n4. Rewrite the query by including the semi-join explicitly with an `ON` clause for the condition and adjusting the `SELECT` list as needed.\n\nExample SQL transformation:\n-- Before transformation\nSELECT Y.* FROM X\nJOIN Y ON X.id = Y.X_id\nWHERE Y.id IN (SELECT Z.Y_id FROM Z WHERE Z.condition = 'value');\n\n-- After transformation\nSELECT Y.* FROM X\nJOIN (SELECT Y.* FROM Y WHERE Y.id IN (SELECT Z.Y_id FROM Z WHERE Z.condition = 'value')) AS Y ON X.id = Y.X_id;"}]}
{"name": "FILTER_SUB_QUERY_TO_CORRELATE", "rewrite_rules_structured": [{"conditions": "The query contains a scalar sub-query within the WHERE clause.", "transformations": "The scalar sub-query should be transformed into a LEFT JOIN operation with an aggregate function on the column(s) being selected in the sub-query. The JOIN condition uses the correlation ID (the matching column(s) in both outer and sub-query).\n  - Original Query Structure: SELECT ... FROM table1 WHERE column = (SELECT AGG_FUNCTION(column2) FROM table2 WHERE table1.join_column = table2.join_column)\n  - Transformed Query Structure: SELECT ... FROM table1 LEFT JOIN (SELECT join_column, AGG_FUNCTION(column2) AS agg_result FROM table2 GROUP BY join_column) AS sub_query ON table1.join_column = sub_query.join_column WHERE column = sub_query.agg_result"}, {"conditions": "The query contains `IN`, `EXISTS`, or `UNIQUE` sub-queries within the WHERE clause that are correlated with the outer query.", "transformations": "- For `IN` Sub-queries: Replace the `IN` clause with a JOIN operation and a WHERE condition that checks for non-null values on the side of the sub-query.\n    - Original Query Structure: SELECT ... FROM table1 WHERE column IN (SELECT column2 FROM table2 WHERE table1.join_column = table2.join_column)\n    - Transformed Query Structure: SELECT ... FROM table1 INNER JOIN table2 ON table1.join_column = table2.join_column WHERE table2.column2 IS NOT NULL\n  - For `EXISTS` Sub-queries: Convert the `EXISTS` condition into a JOIN operation, using WHERE to filter rows that match the JOIN condition.\n    - Original Query Structure: SELECT ... FROM table1 WHERE EXISTS (SELECT 1 FROM table2 WHERE table1.join_column = table2.join_class)\n    - Transformed Query Structure: SELECT DISTINCT table1.* FROM table1 INNER JOIN table2 ON table1.join_column = table2.join_column\n  - For `UNIQUE` Sub-queries: Since `UNIQUE` requires a bit more complex handling not directly mappable to a standard JOIN, it should be considered a special case where the goal is to ensure that rows from the outer query match a unique set in the sub-query. This might not translate directly into SQL syntax without additional sub-query or DISTINCT aggregation."}]}
{"name": "PROJECT_VALUES_MERGE", "rewrite_rules_structured": [{"conditions": "The SQL query must contain a SELECT statement (projection) directly over a VALUES clause (representing a `LogicalValues`). The VALUES clause should contain one or more tuples.", "transformations": "Retrieve the SELECT list expressions. Apply each SELECT list expression to the corresponding elements of each tuple in the VALUES clause. Rewrite the VALUES clause to reflect the outcomes of these operations, changing the original tuple set to a new one where each tuple is transformed based on the corresponding SELECT list expressions."}, {"conditions": "This transformation is implied to occur when projection conditions effectively act as filters (though direct filtering wasn't explicitly covered in the rule, we recognize its potential by considering \"reducing the tuple set size\" as an outcome of applying certain conditions). A projection directly over a non-empty VALUES clause is involved. The SELECT list expressions or WHERE clause (if applicable) imply a reduction in the resulting set of tuples.", "transformations": "Evaluate the SELECT list or WHERE clause conditions against each tuple in the VALUES clause. Exclude tuples that do not meet the implied or explicit conditions. Generate a new VALUES clause with only the tuples that match the conditions."}]}
{"name": "UNION_REMOVE", "rewrite_rules_structured": [{"conditions": "When an SQL query uses `UNION ALL` to combine results from a single subquery or table without integrating it with any other dataset. This occurs when the query structure applies a `UNION ALL` but both (or all) parts of the union involve the exact same dataset, essentially duplicating the dataset without merging it with different data.", "transformations": "1. **Identify the Redundant UNION ALL**: Look for any `UNION ALL` operations in the query where the datasets involved before and after the `UNION ALL` are identical, or if there's a `UNION ALL` applied to a single dataset without actually combining it with another different dataset.\n2. **Simplify the Query**: Remove the `UNION ALL` operation and keep only the subquery or table reference. Since `UNION ALL` with a single source does not filter out duplicates nor does it amalgamate different datasets, it serves no purpose other than potentially increasing execution time and complexity.\n3. **Direct Replacement**: The query previously encapsulated by the `UNION ALL` operation becomes the simplified output, effectively stripping away the unnecessary `UNION ALL`."}]}
{"name": "PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW", "rewrite_rules_structured": [{"conditions": "This rule applies to a SQL query when there are window functions (like `ROW_NUMBER()`, `RANK()`, `SUM()` over a window, etc.) used in the SELECT list of the query. Window functions in SQL are recognized by the presence of an OVER clause.", "transformations": "1. Identify the SELECT clause of the SQL query that contains window functions along with possible other non-windowed expressions or column selections.\n2. Separate the expressions in the SELECT list into two groups:\n   a. Expressions including window functions.\n   b. Non-window expressions or direct column/field references.\n3. Create a subquery or a CTE (Common Table Expression) that performs all the non-windowed expressions or direct selections as a preparatory query or transformation. This step essentially performs what was described as `LogicalCalc` in the relational transformation, where non-window aggregate expressions and direct column references are handled.\n4. In the outer query (built upon the subquery or CTE from step 3), apply all the window functions on the projected columns from the inner query. This step corresponds to the application of `LogicalWindow` where all windowed-aggregate functions are computed.\n5. Ensure that the outer query also reproduces any non-aggregate expressions alongside the window function results, so the final SELECT list mirrors the original in terms of columns returned but is now split between the inner and outer queries to correctly apply window functions.\n6. For all projections and calculations that were internal to the original query's SELECT list (like calculated columns), ensure these are included at the correct query layer (inner or outer) based on whether they are required for window function calculation or are independent of it."}]}
{"name": "AGGREGATE_EXPAND_DISTINCT_AGGREGATES_TO_JOIN", "rewrite_rules_structured": [{"conditions": "If a SQL query uses strictly COUNT(DISTINCT column), SUM(DISTINCT column), MIN(DISTINCT column), or MAX(DISTINCT column) with the same column, and does not include any non-distinct aggregate functions in the SELECT clause, it can be processed without a join operator.", "transformations": "The SQL optimization here involves simplifying the aggregation logic to work over a single group by operation, directly translating to the use of GROUP BY on that column in SQL."}, {"conditions": "If a SQL query contains exactly one distinct aggregate function (e.g., COUNT(DISTINCT column)) and one or more non-distinct aggregates (COUNT, SUM, MIN, MAX) on distinct or the same columns without any filters, it should be transformed as follows: 1. Generate an intermediate SQL query (bottom Aggregate) that groups by both the distinct column(s) and any columns involved in the GROUP BY clause, calculating all distinct aggregates at this stage. 2. Apply a second SQL query (top Aggregate) on top of the intermediate result to compute non-distinct aggregates. 3. If the original query contains operations that logically precede the aggregation (e.g., joins with other tables), incorporate these as necessary before the bottom Aggregate, possibly leading to a join operation. 4. Use a SELECT statement (final Project) to realign the output columns if necessary to match the original query's expected output.", "transformations": "Generate an intermediate SQL query that groups by the distinct and group by columns for distinct aggregates then apply another aggregation on this result for non-distinct aggregates. Join operational tables as necessary before aggregation"}, {"conditions": "For SQL queries involving multiple distinct aggregate functions over different columns (e.g., COUNT(DISTINCT column_a), COUNT(DISTINCT column_b)), the transformation should proceed as follows: 1. Decompose the query into multiple parts, each part handling one of the distinct aggregates. Each part will effectively be an intermediate SQL query that performs a GROUP BY on the distinct column related to its aggregate. 2. Use JOIN operations to combine these intermediate aggregate results based on the common grouping columns that are part of the original GROUP BY clause, if present. 3. Rewrite the initial distinct aggregates in the final SELECT statement to reference the appropriate aggregated results from the combined dataset without using the DISTINCT keyword. 4. Include a final SELECT statement (Project) to ensure that the output columns are correctly named and typed to match the expected result set of the original query.", "transformations": "Decompose the query into parts for each distinct aggregate and GROUP BY the related distinct column. Use JOIN to combine these results based on the common group by columns. Reference the combined dataset aggregates without DISTINCT in the final SELECT to match the original expected result."}]}
{"name": "PROJECT_FILTER_VALUES_MERGE", "rewrite_rules_structured": [{"conditions": "1. A `SELECT` query should perform projection (`SELECT` clause) directly on a filtered result set, where the filtering is defined by a `WHERE` clause.\n2. The source of the featuring (underlying table or result set) for the `WHERE` clause is a fixed set of tuples. In SQL, this would be represented by a subquery or a CTE (Common Table Expression) that explicitly enumerates values using `VALUES` (e.g., `VALUES (1, 'Alice'), (2, 'Bob')...`).\n3. The `VALUES` clause must not be empty, meaning it should contain at least one tuple.", "transformations": "- Identify the portions of the SQL query where a projection (`SELECT` clause) is applied on a filtered dataset (`WHERE` clause), and the dataset itself is a hard-coded or explicitly defined set of tuples (`VALUES`).\n- Determine the filter conditions from the `WHERE` clause and the fields or expressions being projected.\n- Apply the filter conditions directly to the tuples defined in the `VALUES` clause. This might involve removing tuples that do not satisfy the conditions.\n- Apply the projection expressions to the tuples remaining after the filter operation, transforming the content of these tuples as needed.\n- Rewrite the original SQL query to directly select from a new set of tuples generated by the above operations, omitting the separate `SELECT` and `WHERE` clauses. This effectively combines them into a single operation that constructs the final set of tuples with the desired conditions and projections applied."}]}
{"name": "FILTER_INTO_JOIN", "rewrite_rules_structured": [{"conditions": "This SQL query rewrite rule applies when a filter condition is placed on the result set of an INNER JOIN operation. The filter's expressions do not reference columns from both tables involved in the join but can be logically applied to either input of the join to reduce the size of datasets before the join occurs.", "transformations": "If a SQL query contains an INNER JOIN with a WHERE clause that can be logically associated only with columns from one side of the join (either left or right), move these conditions into the ON clause of the INNER JOIN or as a WHERE clause on a subquery of the respective side. Transform `SELECT * FROM A INNER JOIN B ON condition1 WHERE condition2(A)` into `SELECT * FROM A INNER JOIN B ON condition1 AND condition2(A)` if `condition2` only involves columns from A."}, {"conditions": "This rule is applicable when a filter condition applies to the result set of a LEFT or RIGHT OUTER JOIN and the filter applies solely to columns from the non-preserving side of the join. This requires careful consideration as pushing a filter into a WHERE clause of a subquery representing the non-preserving side could change the semantics of the query by inadvertently converting the OUTER JOIN into an INNER JOIN.", "transformations": "For a LEFT OUTER JOIN where a subsequent WHERE clause filters columns from the right table, convert this filter into an AND condition within the ON clause of the JOIN, if it does not alter the expected result set. For instance, transform `SELECT * FROM A LEFT OUTER JOIN B ON condition1 WHERE condition2(B)` to `SELECT * FROM A LEFT OUTER JOIN B ON condition1 AND condition2(B)` cautiously, ensuring that `condition2(B)` does not lead to excluding rows from A which have no corresponding rows in B, effectively preserving the LEFT JOIN semantics."}, {"conditions": "This applies when a subsequent WHERE clause filter mandates the presence of non-NULL values in columns from the non-preserving side of an OUTER JOIN. This specific filtering effectively mandates that there's a matching row in the non-preserving side's table, thus allowing the OUTER JOIN to be converted to an INNER JOIN for efficiency.", "transformations": "Convert OUTER JOINS to INNER JOINS when followed by WHERE clauses that eliminate the possibility of NULL results from the non-preserving side. For example, `SELECT * FROM A LEFT OUTER JOIN B ON condition1 WHERE B.column IS NOT NULL` can be efficiently rewritten as `SELECT * FROM A INNER JOIN B ON condition1` because the WHERE clause enforces a logic that requires a match in B for every row returned."}]}
{"name": "SEMI_JOIN_PROJECT_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "A subquery utilizes a semi-join pattern with conditions that correlate to the outer query's columns, and the semi-join's effectiveness can be improved by direct application to the base tables or earlier in the query execution plan before applying transformations through `SELECT`.", "transformations": "Replaces a pattern where a semi-join (`EXISTS`, `IN`, or a `JOIN ... WHERE` clause) follows a `SELECT` clause with transformed columns or expressions, by moving the semi-join to act directly on the base table. Original: `SELECT column1, expression2 AS alias2 FROM ( SELECT column1, expression2 FROM TableX WHERE EXISTS (SELECT 1 FROM TableY WHERE TableX.column1 = TableY.column1) ) AS subquery` becomes `SELECT column1, expression2 AS alias2 FROM TableX WHERE EXISTS ( SELECT 1 FROM TableY WHERE TableX.column1 = TableY.column1 )`."}]}
{"name": "UNION_TO_DISTINCT", "rewrite_rules_structured": [{"conditions": "When you have a SQL query performing a UNION that implicitly or explicitly excludes duplicates (essentially equivalent to `UNION DISTINCT`), identify this as an optimization opportunity.", "transformations": "Substitute the `UNION DISTINCT` operation with a `UNION ALL` operation paired with an additional `DISTINCT` operation. This is done by constructing a new SQL query where:\n        a. Replace instances of `UNION` (implicitly `UNION DISTINCT`) with `UNION ALL`. This modification creates a concatenated result set inclusive of duplicates from the combined datasets.\n        b. Apply a `DISTINCT` operation over the entire result of the `UNION ALL`. This could be achieved by selecting the results into a subquery followed by selecting distinct from this subquery, or by directly applying operations that ensure uniqueness across the entire dataset."}]}
{"name": "UNION_PULL_UP_CONSTANTS", "rewrite_rules_structured": [{"conditions": "This rule is applicable when a SQL query employs a `UNION` or `UNION ALL` operator with multiple select statements containing constant expressions in their `SELECT` clauses, where these constants are identical across all the select statements. A constant expression refers to values that do not change—like literal values (e.g., `5`, `'constant_string'`), mathematical expressions involving only constants (e.g., `3+4`, `YEAR('2023-01-01')`), or expressions with functions that return the same value irrespective of the row (assuming no random or row-dependent functions are used).", "transformations": "a. **Identify Constants:** Isolate the constant expressions in the `SELECT` clauses of the `UNION` (or `UNION ALL`) queries. Constants are expressions that return the same value for all rows in each select statement within the `UNION`. For example, if multiple select statements as part of a union use a literal string or number in the same position.\n\nb. **Extract and Adjust Constants:** Remove the constant expressions from the select statements in the `UNION` and prepare to add them to a new `SELECT` list that will surround the `UNION`. If necessary, use casting to match the data types of the constants with the data types expected in the final result set.\n\nc. **Rebuild With Projects:** Create a new SQL query structure where:\n  - An outer `SELECT` query is introduced, repeating the constants and selecting the remaining non-constant fields from an inner `UNION` query.\n  - The inner `UNION` query combines the modified select statements that now exclude the constants. This `UNION` is effectively wrapped by the outer `SELECT`.\n  - Ensure that both the outer and (if needed) the inner select lists align in terms, types, and the number of columns, especially when dealing with expressions or when implicit type conversion is required.\n\nd. **Maintain Row Type:** By selecting the constants and other fields in the outer query, ensure that the result's structure (row type) matches what was initially expected by the statement before the rewrite. For instance, if the initial query had a column `constant_column AS 'ConstantValue'`, the rewritten query should also project this column with the same alias and value."}]}
{"name": "JOIN_SUB_QUERY_TO_CORRELATE", "rewrite_rules_structured": [{"conditions": "When a scalar sub-query (a sub-query that returns exactly one row and column) is used as a part of the join condition.", "transformations": "Replace the scalar sub-query with an aggregate function in the select list of a subquery. Then, join this subquery with the outer query using the appropriate join condition. This prevents the need for executing the scalar sub-query for each row of the outer query."}, {"conditions": "When an `EXISTS` sub-query is present in the join condition.", "transformations": "Transform the `EXISTS` sub-query into an equivalent left join. After performing the left join, filter the rows where the join condition with the sub-query table matches (i.e., where the columns from the right-hand side of the join are not null). This accurately replicates the `EXISTS` condition logic."}, {"conditions": "When an `IN` sub-query is used in the join condition.", "transformations": "Translate the `IN` sub-query into an equivalent join condition. This involves creating a join on the condition that matches the outer column(s) with the column(s) specified in the `IN` sub-query. The transformation eliminates the `IN` sub-query, thereby potentially improving performance through better join optimization."}, {"conditions": "When a `SOME` or `ANY` sub-query is part of the join condition.", "transformations": "Convert the `SOME`/`ANY` sub-query into a join by applying the appropriate conditional operation that matches the semantics of `SOME` or `ANY`. This could involve rewriting the condition to ensure it captures the comparison semantics properly, possibly using aggregate functions or distinct operations depending on the logic needed."}, {"conditions": "When a `UNIQUE` sub-query is used in the join condition.", "transformations": "Translate the `UNIQUE` sub-query into a join followed by a `DISTINCT` operation on the resulting joined table. The resulting transformation should ensure that the uniqueness logic is preserved, potentially by performing additional filtering or by ensuring that the join operation does not duplicate rows that would violate the unique constraint implied by the original `UNIQUE` sub-query."}]}
{"name": "SORT_REMOVE", "rewrite_rules_structured": [{"conditions": "The dataset queried in the `SELECT` statement is ordered by a certain column or set of columns. The `ORDER BY` clause specifies the same column(s) in the same order. There are no `OFFSET` or `LIMIT` clauses present in the query.", "transformations": "Remove the `ORDER BY` clause from the query."}, {"conditions": "The dataset queried in the `SELECT` statement is ordered by a certain column or set of numbers. The `ORDER BY` clause specifies the same column(s) in the same logical order. There are `OFFSET` or `LIMIT` clauses present in the query, indicating pagination.", "transformations": "Keep the `ORDER BY` clause intact to preserve the correct pagination of results."}]}
{"name": "SORT_JOIN_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "1. The SQL query utilizes a left outer join.\n2. The ORDER BY clause of the query references columns exclusively from the left table involved in the join.", "transformations": "Move the ORDER BY clause to a subquery that selects from the left table, thereby sorting the data before it is joined to the right table.\nIf the original query had a LIMIT or OFFSET, it should be carefully managed to preserve query semantics."}, {"conditions": "1. The SQL query uses a right outer join.\n2. The ORDER BY clause references columns exclusively from the right table involved in the join.", "transformations": "Move the ORDER BY clause to a subquery that selects from the right table, sorting the data before it is joined to the left table.\nManage LIMIT or OFFSET with caution to ensure the transformation does not change the original query's intention."}, {"conditions": "1. The SQL query utilizes a left or right outer join.\n2. The ORDER BY clause includes an OFFSET (and possibly a LIMIT).\n3. The non-preserved side of the join (right side for left joins, left side for right joins) must be proven or known to be count-preserving.", "transformations": "Due to the complexity and specificity of the condition regarding count-preservation, this rule suggests a more cautious approach, possibly requiring a case-by-case analysis. The optimization should only be applied if there is certainty that the join's non-preserved side does not multiplicate the rows of the preserved side, impacting the sort with offset results."}]}
{"name": "JOIN_LEFT_UNION_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "The SQL join operation has a `UNION ALL` on its left side. The join operation contains no correlated subqueries (i.e., no subqueries referencing columns from the outer query) in its ON clause. The join is not part of an outer join on the null-producing side, ensuring it doesn't unintentionally omit rows that should produce nulls on the outer side when no match is found.", "transformations": "For each input branch of the original `UNION ALL`, create a separate join operation with the right-hand side of the original join. This results in two or more join operations depending on the number of branches in the `UNION ALL`. Retain the same join type and join conditions for each new join operation as in the original join. Combine the results of these new join operations using `UNION ALL`."}]}
{"name": "PROJECT_JOIN_REMOVE", "rewrite_rules_structured": [{"conditions": "You have a SQL query using a `LEFT JOIN` to combine two tables. The `SELECT` clause only includes columns from the left table (`LEFT JOIN` left side). The join condition column(s) from the left table are guaranteed to be unique. This might be confirmed through constraints in the schema or by using a `DISTINCT` or `GROUP BY` operation on the join key columns of the left side before the join.", "transformations": "Remove the `LEFT JOIN` clause and its associated conditions from the query. Adjust the `FROM` clause to only include the left table. Retain the `SELECT` clause as is, ensuring it only demands columns from the formerly mentioned left table. The resulting query should now be significantly simpler and potentially more efficient, as it directly selects the necessary columns from the left table without performing a join."}, {"conditions": "You have a SQL query employing a `RIGHT JOIN` to merge two tables. The `SELECT` clause includes only columns from the right table (`RIGHT JOIN` right side). The join condition column(s) from the right table are unique. This might be ascertained through schema constraints or by including a `DISTINCT` or `GROUP BY` operation on the join key columns of the right side before the join.", "transformations": "Omit the `RIGHT JOIN` clause along with its conditions from the query. Modify the `FROM` clause to solely encompass the right table. Update the `SELECT` clause to ensure it only requests columns from the right table, which was previously on the right side of the join. This may involve adjusting column aliases or referencing specifics to align with the right table's column names and positions. The modified query should now be more straightforward and possibly execute more efficiently by directly accessing the necessary columns from the right table without the overhead of a join."}]}
{"name": "AGGREGATE_ANY_PULL_UP_CONSTANTS", "rewrite_rules_structured": [{"conditions": "The SQL query must use the `GROUP BY` clause with multiple columns, and at least one of these grouping columns must be constant across all rows. Constants can include literals or expressions that evaluate to the same value for all rows. This can typically be identified using statistics or metadata about column values.", "transformations": "1. Identify Constant Group Keys: Examine the `GROUP BY` clause to detect constants. A column is considered a constant if its value is the same for all rows or if it is a literal. Example condition: `GROUP BY 'constant_value', column1, column2` 2. Remove Constant Group Keys: Adjust the `GROUP BY` clause by removing the identified constant keys but ensure at least one column remains in the `GROUP BY` clause. Transformation: `SELECT ... GROUP BY column1, column2` 3. Projection of Constants: Modify the `SELECT` clause to include the constants that were removed from the `GROUP BY` clause. This might require wrapping the original `SELECT` and `GROUP BY` in a derived table or CTE (Common Table Expression) and then selecting from it with the constants added back. Transformation: `SELECT 'constant_value', column1, column2, AGG_FUNC(columnX) FROM ( SELECT column1, column2, columnX FROM table GROUP BY column1, column2 ) AS derived_table` - Here, `AGG_FUNC(columnX)` represents the aggregation functions applied to other columns."}]}
{"name": "FILTER_TABLE_FUNCTION_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "- The SQL query involves a filter operation applied after a table function scan, wherein the table function is used in the `FROM` clause as a lateral join or cross apply.\n- The column mapping from the input to the output of the table function is direct and 1-to-1. This means each input column maps to exactly one output column without transformation.\n- The table function must accept exactly one input table or query.\n- The number of fields output by the table function matches the number of fields input to it, ensuring that for every input field, there is a corresponding and directly relatable output field.", "transformations": "1. Identify the original `SELECT` query structure where a filter is applied after a table function. For example, consider a query structure like:\n   ```sql\n   SELECT ... \n   FROM source_table\n   JOIN LATERAL (SELECT * FROM table_function(input_table_column)) AS tf ON true\n   WHERE conditions_on_tf_output;\n   ```\n2. Rewrite the query by moving the filter conditions to a `WHERE` clause that applies directly on the input to the table function, if applicable, adjusting the conditions to refer to the input columns directly. This may involve modifying field references in the filter condition to align with the input table's column names instead of the table function's output.\n   ```sql\n   SELECT ... \n   FROM source_table,\n        LATERAL (SELECT * FROM table_function(input_table_column) WHERE conditions_adjusted_to_input) AS tf\n   ```\n3. Ensure that the transformed query still applies all original conditions but does so prior to the table function application. This might require adjustments in condition syntax to correctly reference the fields as they exist before the application of the table function."}]}
{"name": "FILTER_PROJECT_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "- The SQL query has a `WHERE` clause that filters results after a set of transformations defined in the `SELECT` clause (simulating a `Filter` over a `Project`).\n- None of the transformations in the `SELECT` clause involve window functions (simulating the exclusion of window functions).\n- The `WHERE` clause does not include conditions dependent on outer query results (no correlation).", "transformations": "1. Identify the transformed columns in the `SELECT` clause referenced in the `WHERE` clause.\n2. Rewrite the `WHERE` clause conditions to target the original columns instead of the transformed ones. This might involve reversing the transformation if possible or applicable.\n3. Apply the rewritten `WHERE` clause before the data undergo:es the transformations specified in the `SELECT` clause - which may require introducing a derived table or Common Table Expression (CTE) to apply the filter conditions directly on the base tables or previous layer of selection.\n4. Maintain the original `SELECT` transformations, but now applied to the possibly reduced result set obtained after the filtering."}]}
{"name": "JOIN_PUSH_EXPRESSIONS", "rewrite_rules_structured": [{"conditions": "When encountering a JOIN operation where the JOIN condition involves an expression using columns exclusively from the LEFT table (e.g., `LEFT_TABLE.column + CONSTANT = RIGHT_TABLE.column`)", "transformations": "1. Adding a new SELECT subquery (or WITH clause) that projects all original columns from the LEFT table plus the expression as a new column.\n2. In the JOIN condition, replace the original expression with a comparison involving the newly added column and the corresponding column from the RIGHT table.\n3. Adjust any SELECT statements to ensure the new column is correctly processed or integrated into the final result set if needed."}, {"conditions": "When encountering a JOIN operation where the JOIN condition involves an expression using columns exclusively from the RIGHT table (e.g., `LEFT_TABLE.column = RIGHT_TABLE.column + CONSTANT`)", "transformations": "1. Adding a new SELECT subquery (or WITH clause) that projects all original columns from the RIGHT table plus the expression as a new column.\n2. In the JOIN condition, replace the original expression with a comparison involving the corresponding column from the LEFT table and the newly added column.\n3. Adjust any SELECT statements to ensure the new column is accounted for or integrated into the final result set if needed."}]}
{"name": "AGGREGATE_JOIN_TRANSPOSE_EXTENDED", "rewrite_rules_structured": [{"conditions": "1. The SQL query must perform a `JOIN` operation immediately followed by a `GROUP BY` aggregation.\n2. The columns used for joining must have unique values (a uniqueness constraint or a primary-foreign key relationship could ensure this).\n3. The `JOIN` condition must consist solely of equi-joins (i.e., using `=` operator).\n4. All aggregate functions used in the `SELECT` clause must be such that they can be evaluated before the join without affecting the result. This typically includes aggregates like `SUM()`, `COUNT()`, `MIN()`, and `MAX()` but not those that inherently depend on the join product like `COUNT(DISTINCT ...)` if the distinction depends on columns from both sides of the join.", "transformations": "1. Identify the aggregate functions in the `SELECT` statement and which side of the join their arguments come from.\n2. For aggregates whose arguments come solely from one side of the join, move the aggregate operation to a subquery that selects from only that side.\n3. Construct a new `JOIN` operation that uses these subqueries as inputs.\n4. Optionally, if further aggregation is necessary (e.g., because of COUNT(*) that includes rows from both sides), perform it on the result of the join."}]}
{"name": "AGGREGATE_CASE_TO_FILTER", "rewrite_rules_structured": [{"conditions": "1. The SQL query must contain an aggregate function (`SUM`, `AVG`, `COUNT`, etc.) that operates on a CASE expression with a format resembling `CASE WHEN <condition> THEN <expression> END`.\n2. This CASE expression must be the sole argument to the aggregate function.\n3. The aggregate function must not be part of a more complex expression within the `SELECT` clause (i.e., it can be directly transformed).", "transformations": "- Identify the CASE expression within the aggregate function in the `SELECT` clause. Confirm it has the required structure (`CASE WHEN <condition> THEN <expression> END`).\n- Rewrite the aggregate function to remove the CASE expression and incorporate the filtering directly. Use the SQL `FILTER` clause to specify the same condition found in the original CASE expression.\n- Adjust the `SELECT` clause to include the updated aggregate function, now with the `FILTER (WHERE <condition>)` clause."}]}
{"name": "AGGREGATE_UNION_AGGREGATE_SECOND", "rewrite_rules_structured": [{"conditions": "1. The query must use `UNION ALL` between two select queries.\n2. The right select query of the `UNION ALL` must use a `GROUP BY` clause without any aggregate functions in the `SELECT` list.\n3. The left select query and the right query after the `GROUP BY` must have the same or compatible row types. Compatibility here means they select the same number of columns with compatible data types, potentially requiring a `Project` (implemented via column selection in `SELECT`) to match.\n4. The `UNION ALL` does not already have a `GROUP BY` on top of it.", "transformations": "1. Check and ensure the row types of both parts of the `UNION ALL` are compatible. If they are not, adjust the `SELECT` list of one or both queries to match by adding a \"project\" step, which means selecting columns explicitly to ensure the row types match.\n2. Combine both queries with `UNION ALL` without changing the original `SELECT` lists, assuming row type compatibility has been achieved.\n3. Apply a `GROUP BY` clause on the result of the `UNION ALL` operation, using the same columns as listed in the `SELECT` list of the right query part of the original `UNION ALL`. This new `GROUP BY` replaces the need for the initial `Aggregate` on the right query part and aims to remove duplicates from the entire result set.\n4. Ensure that the final query selects columns in a manner consistent with the original query, maintaining the semantics of the original grouping (even though no original aggregate functions were used)."}]}
{"name": "PROJECT_REMOVE", "rewrite_rules_structured": [{"conditions": "You have a SQL query with a subquery or derived table where the outer query merely selects the same columns as produced by the subquery without applying any transformations, functions, or renaming and where the subquery does not require the outer query for scoping column names.", "transformations": "Remove the outer query (or derived table) and use the subquery directly."}, {"conditions": "You have a SQL query with an outer query that selects columns from a subquery or derived table involving only trivial operations like renaming of columns without modifying their values.", "transformations": "Combine the outer query and the subquery (or derived table) into a single query by adopting the column names specified in the outer query. If the outer query renames columns, apply these renamings directly in the subquery or derived table."}]}
{"name": "JOIN_REDUCE_EXPRESSIONS", "rewrite_rules_structured": [{"conditions": "This rewrite is applicable to SQL JOIN operations where the joining condition includes constant expressions that can be simplified (e.g., arithmetic operations involving constants, comparisons between constants, or operations that lead to a constant under standard mathematical rules).", "transformations": "In the SQL query, identify the JOIN condition within the ON clause that has constant expressions. Replace those constant expressions with their calculated values or simplified form. This process should ignore any expressions that involve dynamic function calls as they cannot be reliably evaluated at rewrite time. For example, a JOIN condition like `ON table1.col1 = table2.col2 AND 1 + 2 = 3` can be simplified to `ON table1.col1 = table2.col2 AND true`."}, {"conditions": "This rule is applicable when the JOIN condition in an SQL query includes redundant casts (for example, casting a value to its own type) or operations that don't alter the essence of the condition but may impact execution efficiency.", "transformations": "Inspect the JOIN condition for redundancies such as unnecessary casts (e.g., CAST(col AS INT) where col is already an INT) or operations that can be simplified. Simplify these by removing the redundant parts or optimizing the operation. This should be done cautiously to preserve the logic of the original query, ensuring that the nullability of the result isn't negatively impacted unless such change doesn't affect the outcome due to the join type or data constraints."}]}
{"name": "PROJECT_REDUCE_EXPRESSIONS", "rewrite_rules_structured": [{"conditions": "- The SQL query includes select expressions with constant arithmetic expressions or nested functions that can be simplified to a constant.\n- Nullability of the columns involved in the expressions should not be affected by the simplification.\n- Dynamic SQL functions or procedures, which might yield different outputs on each call, are excluded from simplification.", "transformations": "1. Identify constant expressions in the SELECT list of the query. These include arithmetic operations, string concatenations, or fixed-input functions where all inputs are constants.\n2. Evaluate these constant expressions and replace them with the literal values in the SQL SELECT list. Ensure that the datatype and nullability of the result columns are preserved. For instance, if a non-nullable column is involved in an operation that can yield null (e.g., division by zero), such expressions should be carefully handled or excluded from simplification.\n3. Rewrite the original SQL query with the simplified expressions in the SELECT list while ensuring other aspects of the query (such as WHERE, GROUP BY, ORDER BY clauses) remain unchanged."}, {"conditions": "- The SQL query contains SELECT expressions with CAST operations that do not alter the data type of the column except to change or adjust nullability.\n- The rule should only be applied if nullability characteristics can be preserved post-removal of the cast.", "transformations": "1. Within the SELECT list, identify CAST operations that are redundant. These can be casts where the source and target data types are the same.\n2. Evaluate the nullability requirements of the expression post-cast removal, ensuring that they match the original intentions. If `matchNullability` is true, only remove casts that do not affect the nullability status of the expression.\n3. Remove redundant cast operations, rewriting the SQL query with the refined expressions in the SELECT list."}]}
{"name": "WINDOW_REDUCE_EXPRESSIONS", "rewrite_rules_structured": [{"conditions": "This rule applies to SQL queries using window functions where the operands of aggregation functions (SUM, AVG, etc.) within the OVER() clause can be simplified. Operands include constant expressions or expressions with redundant casts.", "transformations": "Constant expressions within the aggregation functions are evaluated to literals. Redundant casts within the operands are removed."}, {"conditions": "This rule is applied when the grouping columns (PARTITION BY) or order by columns (ORDER BY within OVER clause) in a window function can be statically determined as constant expressions throughout the query execution.", "transformations": "Grouping columns or sorting columns that are constant expressions are replaced with those constants, potentially simplifying the grouping logic and reducing the number of keys."}, {"conditions": "After adjustments in keys or order keys due to optimizations including but not limited to constant expression replacements, new window groups and collations are needed.", "transformations": "Form new groups and adjust collations in the OVER() clause to reflect a more streamlined and optimized sorting and grouping strategy."}, {"conditions": "If any significant optimizations are made such as operand simplification, key adjustments, or collation restructuring, a new logical window structure is proposed to replace the original.", "transformations": "Reconstruct the window function clause with the optimized groups, keys, and adjusted collations. This might involve rewriting the entire OVER() clause or even changing the structure of the query to better fit the optimizations made."}]}
{"name": "FILTER_REDUCE_EXPRESSIONS", "rewrite_rules_structured": [{"conditions": "If the WHERE clause of a SELECT query contains conditions that can be statically determined as always true (e.g., constant expressions like `1=1` or tautologies based on the column data types and constraints), then these conditions don't affect the result set.", "transformations": "Remove such conditions from the WHERE clause. If this results in an empty WHERE clause, remove the WHERE clause entirely."}, {"conditions": "If the WHERE clause simplifies to conditions that are always false or involve comparisons with NULL in a way that the outcome is always false or NULL (e.g., `column != column` or `1=0`), indicating no rows can satisfy the filter.", "transformations": "Replace the query with one that selects no rows. This could be represented in different ways based on the SQL dialect. One universal method might be selecting from a dual table with a false condition."}, {"conditions": "If the WHERE clause of a SELECT query contains complex conditions that can be simplified based on known constraints, constants, or through logical simplification (e.g., `column IS NOT NULL AND column IS NOT NULL` simplifies to `column IS NOT NULL`).", "transformations": "Simplify the conditions according to logical rules and known constraints. Remove redundancy and unnecessary complexity."}]}
{"name": "PROJECT_FILTER_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "This rewrite rule can be applied when an SQL query contains a SELECT operation (acting as the `Project` operation) followed by a WHERE clause (acting as the `Filter` operation), provided that the SELECT does not contain window functions (such as RANK(), ROW_NUMBER(), etc.) and the columns selected do not affect the outcome of the WHERE clause.", "transformations": "To apply the rule, refactor the SQL query so that the conditions in the WHERE clause are evaluated before the columns are selected in the SELECT clause. This may involve moving computations or column transformations from the SELECT clause to a sub-query that the WHERE clause is applied on, ensuring the final SELECT clause on the outermost query matches the original query's expected outcome. - Before: SELECT col1, transformation_function(col2) FROM table WHERE condition; - After: SELECT col1, transformation_function(col2) FROM (SELECT col1, col2 FROM table WHERE condition) AS subquery;"}]}
{"name": "PROJECT_JOIN_JOIN_REMOVE", "rewrite_rules_structured": [{"conditions": "1. The SQL query must involve a SELECT statement (a Project operation) atop a JOIN operation.\n2. The FROM clause of the JOIN operation involves another JOIN operation on its left side, specifically a LEFT JOIN.\n3. The columns selected in the SELECT statement must not include any columns from the right table of the bottom (inner) LEFT JOIN that is considered for removal.\n4. The join conditions for the top JOIN must not depend on the columns from the right table of the bottom JOIN.\n5. The join keys (the columns on which the JOIN condition is based) on the left inputs of both the top and bottom JOINS must be the same.\n6. The rows from the right child table of the bottom JOIN must be unique based on the join key.", "transformations": "1. Verify that the selected columns in the SQL query's SELECT statement only include columns from the left table of the bottom JOIN or from tables not involved in the bottom JOIN.\n2. Confirm that the join condition of the top JOIN does not depend on the right table of the bottom JOIN and that the join keys are equivalent across both JOINS.\n3. Ensure uniqueness of the join keys in the right table of the bottom JOIN.\n4. Rewrite the SQL query by removing the bottom JOIN operation, and if necessary, adjust the JOIN condition in the FROM clause to reflect the direct connection between the left table of the original bottom JOIN and the remaining table in the JOIN operation.\n5. Adjust the SELECT statement if necessary to account for any columns that were removed along with the bottom JOIN, ensuring the output columns remain consistent with the original intent of the query."}]}
{"name": "JOIN_EXTRACT_FILTER", "rewrite_rules_structured": [{"conditions": "1. The SQL query must utilize an INNER JOIN.\n2. The JOIN condition (ON clause) must contain specific conditions comparing fields from the two tables involved (e.g., table1.columnA = table2.columnB), and not simply be TRUE (indicating an intentional relationship between the tables).\n3. The query must not involve system fields (fields whose presence is meant for internal database or system-level operations and not directly related to the application's business logic).", "transformations": "- Step 1: Create a Cartesian Join:\n  - Initially, replace the specific JOIN condition with a TRUE condition to create a Cartesian product. This step involves modifying the SQL query such that the ON clause effectively allows every row from the left table to join with every row from the right table.\n  - The FROM clause that initially might look like this: `FROM table1 INNER JOIN table2 ON table1.columnA = table2.columnB` should be changed to `FROM table1, table2`, or, to maintain the INNER JOIN syntax for clarity, `FROM table1 INNER JOIN table2 ON TRUE`.\n\n- Step 2: Apply Original Filter Condition:\n  - After creating the Cartesian Join, apply the original join condition as a WHERE filter. The modified query structure would include a WHERE clause that contains the original join conditions.\n  - The SQL modification results in adding a WHERE clause right after the FROM clause from Step 1, leading to: `FROM table1, table2 WHERE table1.columnA = table2.columnB`."}]}
{"name": "PROJECT_AGGREGATE_MERGE", "rewrite_rules_structured": [{"conditions": "The rule applies when all aggregate functions used within a `GROUP BY` clause (`Aggregate` operation) of a SQL query are directly reflected in the `SELECT` clause (corresponding to the `Project` operation) without any `CASE` statements modifying or conditionally selecting these aggregates.", "transformations": "No changes are made to the SQL query, as the alignment of the `GROUP BY` aggregates with the `SELECT` clause indicates there is no inefficiency in aggregate usage to optimize."}, {"conditions": "Within a `SELECT` clause involving a `GROUP BY` clause, any `COALESCE(SUM(column), 0)` expression is targeted for transformation.", "transformations": "Replace the `COALESCE(SUM(column), 0)` with a `SUM0(column)` function call in the SQL query. This optimizes the aggregation process by streamlining the handling of null values and potentially improving the efficiency of the merging operations in the database engine."}, {"conditions": "Aggregate functions that are present in the `GROUP BY` operation, but whose results are not used in the `SELECT` clause's expressions (outside of any `CASE` structures), are identified as removable.", "transformations": "Modify the SQL query by removing these unused aggregate calls from both the `SELECT` clause and the aggregate function list in a `GROUP BY` clause, streamlining the query and potentially reducing computational overhead."}, {"conditions": "After any removal or transformation of aggregate calls in the SQL query as described in Rule 2 or Rule 3, if there's any discrepancy between the outputs expected by the downstream SQL operations and the actual outputs due to these transformations.", "transformations": "Adjust the SQL query to correct any column references or aliases in the `SELECT` clause and possibly in the `ORDER BY`, `HAVING`, and other clauses, to reflect the updated set of aggregate calls. This ensures that subsequent operations in the SQL query accurately refer to the correct columns post-transformation."}]}
{"name": "JOIN_PUSH_TRANSITIVE_PREDICATES", "rewrite_rules_structured": [{"conditions": "1. A SQL JOIN operation is identified.\n2. It is possible to infer filtering conditions that are applicable to the left table involved in the join operation, based on the join condition and other available predicates.", "transformations": "1. Infer the predicates (conditions) that can be applied to the left table. This requires analyzing the join conditions and any relevant WHERE clauses that might yield conditions applicable to the left input of the join.\n2. Wrap the left table in a SELECT statement with a WHERE clause applying the inferred predicates. This is equivalent to applying a filter operation on the left input of the join.\n3. Perform the JOIN operation as originally intended, but now using the filtered left input."}, {"conditions": "1. A SQL JOIN operation is identified.\n2. It is possible to infer filtering conditions that are applicable to the right table involved in the join operation, based on the join condition and other available predicates.", "transformations": "1. Infer the predicates (conditions) that can be applied to the right table. This involves analyzing the join conditions and any relevant WHERE clauses for conditions applicable to the right input of the join.\n2. Wrap the right table in a SELECT statement with a WHERE clause applying the inferred predicates, effectively applying a filter operation on the right input of the join.\n3. Conduct the JOIN operation using the filtered right input as initially planned."}]}
{"name": "FILTER_EXPAND_IS_NOT_DISTINCT_FROM", "rewrite_rules_structured": [{"conditions": "This transformation applies to SQL `WHERE` clauses that contain the `IS NOT DISTINCT FROM` operation.", "transformations": "1. Identify the SQL query that uses `IS NOT DISTINCT FROM` in its `WHERE` clause. This operation looks for equality that includes `NULL` values in the comparison (i.e., `a IS NOT DISTINCT FROM b` effectively behaves like `(a = b) OR (a IS NULL AND b IS NULL)`).\n2. Rewrite the SQL query to replace the `IS NOT DISTINCT FROM` operation with a logically equivalent `CASE` expression. The replacement logic is constructed as follows:\n    - If either operand involved in the `IS NOT DISTINCT FROM` operation is `NULL`, the `CASE` expression evaluates conditions that mimic the original operation's intent.\n    - Specifically, construct a `CASE` expression that checks:\n        * If both operands are `NULL`, return `TRUE` (since `NULL IS NOT DISTINCT FROM NULL` evaluates to `TRUE`).\n        * If one operand is `NULL` and the other is not, return `FALSE`.\n        * Otherwise, return the result of the standard equality check (`=`) between the two operands.\n3. Implement the transformation in your SQL query. For example, transform a `WHERE` clause like this:\n    - Original: `WHERE a IS NOT DISTINCT FROM b`\n    - Transformed: `WHERE CASE WHEN a IS NULL AND b IS NULL THEN TRUE WHEN a IS NULL OR b IS NULL THEN FALSE ELSE a = b END`\n4. Ensure the transformed query is tested for correctness, paying particular attention to the handling of `NULL` values in the comparisons to ensure the logic correctly emulates `IS NOT DISTINCT FROM`."}]}
{"name": "JOIN_RIGHT_UNION_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "1. The SQL query involves a JOIN operation (either INNER JOIN, LEFT OUTER JOIN, or FULL OUTER JOIN) where the JOIN's right operand is a UNION ALL operation.\n2. The JOIN is not correlated, meaning it does not depend on columns outside the scope of its direct input relations.", "transformations": "1. Identify the JOIN operation that has a UNION ALL on its right.\n2. Rewrite the query by pushing the JOIN operation inside the UNION ALL. This means applying the JOIN separately to each input of the original UNION ALL, using the same join condition.\n3. The output of the separate JOIN operations is then combined using another UNION ALL.\n\nIf original query looked like:\n```sql\nSELECT * FROM A\nJOIN (\n  SELECT * FROM B\n  UNION ALL\n  SELECT * FROM C\n) AS D ON A.id = D.id;\n```\n\nIt should be transformed into:\n```sql\nSELECT * FROM A\nJOIN B ON A.id = B.id\nUNION ALL\nSELECT * FROM A\nJOIN C ON A.id = C.id;\n```"}, {"conditions": "1. The SQL query involves a JOIN operation (either INNER JOIN, RIGHT OUTER JOIN, or FULL OUTER JOIN) where the JOIN's left operand is a UNION ALL operation.\n2. The JOIN is not correlated.", "transformations": "1. Identify the JOIN operation that has a UNION ALL on its left.\n2. Rewrite the query by pushing the JOIN operation inside the UNION ALL. This means applying the JOIN separately to each input of the original UNION ALL, with the same join condition.\n3. The results of these separate JOIN operations are then combined using another UNION ALL.\n\nIf the original query looked like:\n```sql\nSELECT * FROM (\n  SELECT * FROM A\n  UNION ALL\n  SELECT * FROM B\n) AS D\nJOIN C ON D.id = C.id;\n```\n\nIt should be transformed into:\n```sql\nSELECT * FROM A\nJOIN C ON A.id = C.id\nUNION ALL\nSELECT * FROM B\nJOIN C ON B.id = C.id;\n```"}]}
{"name": "PROJECT_MERGE", "rewrite_rules_structured": [{"conditions": "when two successive SELECT clauses essentially reorder columns but do not replicate the input (non-identity)", "transformations": "combine these into a single SELECT by reordering the columns according to the combined effect of both reorders"}, {"conditions": "if a SELECT clause directly following another SELECT clause does not change the column order or content (an identity projection)", "transformations": "remove the unnecessary SELECT operation entirely, rather than merging"}, {"conditions": "avoid merging two consecutive SELECT clauses if doing so would exponentially increase the query's complexity", "transformations": "leave them as separate"}, {"conditions": "if consecutive SELECT operations can be combined into one where the resulting SELECT is an identity projection", "transformations": "remove both SELECT layers and use the source directly"}, {"conditions": "for two successive SELECT operations that don't simply reorder columns and whose merger does not result in undue complexity", "transformations": "merge into one SELECT by integrating the expressions from the first SELECT clause into the second one, adapting any necessary changes in column referencing"}]}
{"name": "SORT_PROJECT_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "If a SQL query executes a sort operation on columns that are directly referenced in the SELECT list or through expressions that are strictly monotonic transformations of these columns, and the sort operation directly follows these projections (SELECT statements), the sort operation can be pushed to operate directly on the table (FROM clause) before the projection.", "transformations": "1. Check Compatibility: Ensure both sort and project (SELECT and ORDER BY clauses) involve compatible operations that relate directly to the raw column data or involve monotonic transformations.\n2. Analyze Order By Fields: Verify that each column in the ORDER BY clause is directly represented in the SELECT list or is a derived column through a monotonic transformation (e.g., casting integers to floats where the order is preserved).\n3. Adjust SQL Query: Rewrite the query so that sorting (ORDER BY clause) is applied to the raw table data in the FROM clause rather than after the projection. This might involve introducing a subquery or CTE (Common Table Expression) where the sorting is applied first, followed by the projections.\n4. Optimize Projection: Ensure that the SELECT list in the outer query matches the original projection, applying on top of the sorted data now."}]}
{"name": "PROJECT_SET_OP_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "This rule is applicable when a SQL query involves a `SELECT` statement (representing `LogicalProject`) above a `UNLON`, `INTERSECT`, or `EXCEPT` clause where none of the selected columns involve SQL window functions, and the set operation does not explicitly aim for distinct results unless the projection itself ensures uniqueness.", "transformations": "1. Identify columns and expressions in the `SELECT` list that do not involve window functions.\n2. Redistribute these columns and expressions directly into the `SELECT` statements of the queries participating in the set operation, adjusting their references if necessary.\n3. Construct a new set operation clause (`UNION`, `INTERSECT`, `EXCEPT`) combining modified subqueries.\n4. Ensure any final adjustments in a wrapping `SELECT` statement if the original `LogicalProject` included operations not suitable for pushing down."}, {"conditions": "This rule applies when the `SELECT` statement involves SQL window functions. In those cases, project expressions that don't involve window functions can be pushed down.", "transformations": "1. Isolate expressions in the `SELECT` list not associated with window functions.\n2. Push these down into the subqueries of the set operation as much as possible, while retaining expressions with window functions at their current level.\n3. Adjust references accordingly for both the pushed-down components and those retained due to their complexity or dependencies on window functions."}]}
{"name": "JOIN_TO_CORRELATE", "rewrite_rules_structured": [{"conditions": "The join type is either INNER JOIN or LEFT JOIN. There are no requirements in the query that would inherently create NULL values on the left side when there are no matching rows on the right side (for INNER JOIN, this condition is naturally met; for LEFT JOIN, it is met if every row on the left side has at least one corresponding row on the right side according to the join condition).", "transformations": "1. Identify the INNER JOIN or LEFT JOIN condition in the SQL query. 2. Extract the ON clause representing the join condition. 3. For INNER JOIN: - Replace the INNER JOIN with a WHERE EXISTS clause, moving the original join condition into the WHERE clause of a subquery that selects from the right side table. Reference the left side columns as correlation variables in the subquery's WHERE clause. - Example Transformation: SELECT * FROM left_table INNER JOIN right_table ON left_table.id = right_table.foreign_id Becomes: SELECT * FROM left_table WHERE EXISTS (SELECT 1 FROM right_table WHERE left_table.id = right_table.foreign_id) 4. For LEFT JOIN: - Replace the LEFT JOIN with a LEFT OUTER JOIN subquery that is correlated to the outer query. In the SELECT clause of the outer query, include a CASE statement or similar logic to handle selection from the subquery result. - Example Transformation: SELECT left_table.*, right_table.* FROM left_table LEFT JOIN right_table ON left_table.id = right_table.foreign_id Becomes: SELECT left_table.*, COALESCE(subquery.alias1, 'default') FROM left_table LEFT OUTER JOIN (SELECT foreign_id, column1 AS alias1 FROM right_table) subquery ON left_table.id = subquery.foreign_id"}]}
{"name": "PROJECT_JOIN_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "The SELECT clause (which represents the projection in SQL) does not involve window functions (the equivalent of `RexOver` expressions in the transformation rule). The SELECT clause does not contain CAST expressions changing columns from nullable to non-nullable types without altering the data type.", "transformations": "1. Identify the columns in the SELECT clause involved in the join condition or required in the final output. 2. For each table involved in the JOIN operation: - Create a new SELECT subquery that selects only the columns necessary for the join condition or required in the final SELECT projection. - Ensure the JOIN condition in the main query references the correct columns in the subqueries. 3. Adjust the main SELECT clause to refer to the columns in the subqueries correctly."}]}
{"name": "FILTER_CORRELATE", "rewrite_rules_structured": [{"conditions": "This rule is applicable in the context of SQL queries when there's a correlated subquery (representing the `Correlate` operation) which could be either a scalar subquery, EXISTS, NOT EXISTS, or any form that results in correlation, and there are filter conditions (WHERE clause predicates) that may be applicable directly to either the inner correlated subquery or the main outer query.", "transformations": "1. **Detect Correlated Subquery with Filters**: Identify if there's a WHERE clause that applies filters directly on a correlated subquery or the main query that includes it.\n\n2. **Decompose Filters**: Split the WHERE clause conditions into individual components if they are combined using AND operators.\n\n3. **Classify Filters**:\n   - Filters that only reference columns from the outer query should remain or be pushed closer to where those columns originate.\n   - Filters that only reference columns from the inner correlated subquery can be pushed inside the subquery, possibly reducing the data processed by it.\n   - Filters that reference columns from both might need to stay where they are or be evaluated for optimization on a case-by-case basis.\n\n4. **Apply Filters**:\n   - For filters that pertain only to the outer query, ensure they are placed in the WHERE clauses appropriate to those parts of the query.\n   - For filters that pertain to the inner subquery, modify the subquery to include a WHERE clause (if not already present) or append these conditions to the existing WHERE clause of the subquery.\n\n5. **Reconstruct Correlated Subquery**: If the subquery's filter conditions have been modified as per the above, adjust the query accordingly, ensuring the correlation remains intact but possibly operates on a reduced data set.\n\n6. **Final Adjustment**: Ensure any remaining filters that could not be pushed down (because they depend on both inner and outer queries) are properly placed to filter the results of the correlated query as a whole.\n\n7. **Optimize Execution Plan**: The goal is to optimize the query's execution by reducing the amount of data processed by the correlated subquery and thus by the whole includes."}]}
{"name": "SEMI_JOIN_FILTER_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "This rule applies when a SQL query involves a semi-join (for example, using `IN`, `EXISTS`, or a join with a distinct condition to emulate a semi-join) that is immediately followed by a `WHERE` clause applying a filter condition. Specifically, if a query has a pattern where a subquery (acting as a semi-join) is used to filter the main query results, and then a separate filter condition is applied to the results of that main query.", "transformations": "1. **Original Structure:** A query where a semi-join is used followed by a `WHERE` clause. For example, this could be a query selecting rows from a table `A` based on whether a condition exists in table `B`, immediately followed by another condition filtering the results from `A`.\n\n    ```sql\n    SELECT a.*\n    FROM A a\n    WHERE a.id IN (SELECT b.a_id FROM B b WHERE b.condition = 'value')\n    AND a.filter_column = 'filter_value';\n    ```\n\n    2. **Transformed Structure:** Rewrite the query by wrapping the filter condition together with the main table in a subquery (or a common table expression), and then apply the semi-join condition on the results of this subquery. This means effectively swapping the order of the `WHERE` clause and the semi-join condition.\n\n    ```sql\n    SELECT a.*\n    FROM (\n        SELECT * FROM A a\n        WHERE a.filter_contact = 'filter_value'\n    ) AS a_filtered\n    WHERE a_filtered.id IN (SELECT b.a_id FROM B b WHERE b.condition = 'value');\n    ```"}]}
{"name": "JOIN_DERIVE_IS_NOT_NULL_FILTER_RULE", "rewrite_rules_structured": [{"conditions": "For an INNER JOIN SQL query, if the join condition implicitly or explicitly dictates that certain columns must not contain `NULL` values for the join to be possible (i.e., the columns are part of an equi-join condition, comparison, or used in a way where `NULL` would cause the condition to evaluate to false)", "transformations": "\n1. **Identify Columns Requiring Non-Null Constraints**: Examine the join condition to determine which columns cannot contain `NULL` values for the condition to be true. This applies to both sides of the join (LEFT and RIGHT inputs).\n\n2. **Generate \"IS NOT NULL\" Filters**: For each of these identified columns, generate an \"IS NOT NULL\" condition.\n\n3. **Apply \"IS NOT NULL\" Filters to Inputs**:\n    - For each LEFT input column identified, add a WHERE clause (or AND to an existing WHERE clause) in the query that selects from the left table/input to filter out rows where these columns are `NULL`.\n    - Do likewise for each RIGHT input column by modifying the query that selects from the right table/input.\n\n4. **Construct Filtered Inputs**: The modifications in step 3 result in two potentially smaller sets of input data for the join operation. These sets exclude rows where the identified columns are `NULL`.\n\n5. **Create Updated Join Operation**: Use the newly filtered sets as inputs in the original join operation. This operation can be the same INNER JOIN SQL query, but now it operates on the filtered inputs that exclude `NULL` values in the critical columns.\n\n- **Before**: \n```sql\nSELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.fk_id;\n```\n- **After** (assuming `table1.id` and `table2.fk_id` cannot be `NULL` for the join condition to hold):\n```sql\nSELECT * \nFROM table1 \nINNER JOIN table2 \nON table1.id = table2.fk_id \nWHERE table1.id IS NOT NULL AND table2.fk_id IS NOT NULL;\n```\n"}]}
{"name": "INTERSECT_TO_DISTINCT", "rewrite_rules_structured": [{"conditions": "This rule applies to SQL queries intending to find a distinct intersection of two or more sets using the INTERSECT operator. It is particularly beneficial when the underlying database does not support the INTERSECT operator or when an alternative execution strategy offers performance benefits.", "transformations": "For each query (subquery or table) Qn that would have been intersected, transform it as follows: SELECT Col1, Col2, ..., ColN, COUNT(*) as c FROM Qn GROUP BY Col1, Col2, ..., ColN. Combine all the previously transformed queries from step (a) using UNION ALL. This operation aggregates the counts of identical rows from each input set: SELECT Col1, Col2, ..., ColN, c FROM (TransformedQuery1 UNION ALL TransformedQuery2 UNION ALL ... TransformedQueryN). Apply another GROUP BY on the result of the UNION ALL operation, grouping by the original attributes to calculate the total count of each unique row across all inputs: SELECT Col1, Col2, ..., ColN, SUM(c) as total_c FROM (ResultOfUnionAll) GROUP BY Col1, Col2, ..., ColN. Filter the result based on total_c being equal to the number of input sets (indicating that the row appears in all sets): SELECT Col1, Col2, ..., ColN FROM (ResultOfSecondGroupBy) WHERE total_c = NumberOfInputSets. Projection: The final step projects out the original columns, effectively discarding the count columns and any other temporary columns added during the transformation process."}]}
{"name": "FILTER_AGGREGATE_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "1. A SQL query uses a WHERE clause (for conditions on unaggregated columns) or a HAVING clause (for conditions on aggregated columns) after a GROUP BY clause.\n2. The conditions within the WHERE or HAVING clause only reference columns specified in the GROUP BY clause.", "transformations": "- Move the filter conditions from the WHERE or HAVING clause to the WHERE clause of a subquery that performs the GROUP BY aggregation. This allows for the conditions to be applied before the aggregation process.\n\nOriginal SQL Query Structure:\nSELECT column_list, AGG_FUNC(column_name)\nFROM table_name\nGROUP BY column_ap_list\nHAVING conditions_on_grouping_columns;\n\nTransformed SQL Query Structure:\nSELECT column_list, AGG_FUNC(column_name)\nFROM (SELECT * FROM table_name WHERE conditions_on_grouping_columns) AS subquery\nGROUP BY column_list;"}, {"conditions": "1. A SQL query has a HAVING clause with conditions that reference both the columns specified in the GROUP BY clause and the results of aggregate functions.\n2. The filter conditions need to be separated into those that can be evaluated before aggregation (referencing grouping columns) and those that must be applied after (referencing aggregated results).", "transformations": "- Separate the conditions in the HAVING clause into two groups: those referencing only grouping columns and those referencing aggregated results.\n- Apply the grouping column references as a WHERE condition in a subquery that performs the GROUP BY, and retain the aggregated results references in a HAVING clause after the GROUP BY operation.\n\nOriginal SQL Query Structure:\nSELECT column_list, AGG_FUNC(column_name) \nFROM table_name \nGROUP BY column_list\nHAVING conditions_on_grouping_columns AND conditions_on_aggregated_results;\n\nTransformed SQL Query Structure:\nSELECT column_list, AGG_FUNC(column_name) \nFROM (SELECT * FROM table_name WHERE conditions_on_grouping_columns) AS subquery \nGROUP BY column_list\nHAVING conditions_on_aggregated_results;"}]}
{"name": "JOIN_PROJECT_RIGHT_TRANSPOSE_INCLUDE_OUTER", "rewrite_rules_structured": [{"conditions": "1. The JOIN is followed by a SELECT operation on the right table.\n2. The SELECT operation does not involve windowed-aggregate functions.", "transformations": "1. Move the SELECT operation to be over the entire JOIN result. This means applying the SELECT clause's expressions to the outputs of the JOIN operation.\n2. Ensure all expressions in the moved SELECT clause correctly reference fields provided by the JOIN operation.\n3. For fields originating from the right table in the JOIN, adjust references to ensure they map to the correct fields post-transformation."}, {"conditions": "1. The query involves an OUTER JOIN followed by a SELECT operation on the right table.\n2. The SELECT operation is valid for movement above the JOIN, which assumes no windowed-aggregate functions are involved.", "transformations": "1. Move the SELECT operation to be over the entire JOIN, ensuring to adjust expressions related to nullability and correct field references.\n2. In case of adjustments for nullability or type inconsistencies brought by the OUTER JOIN, apply explicit casting or COALESCE() as needed to maintain the intended semantics."}]}
{"name": "JOIN_PROJECT_LEFT_TRANSPOSE_INCLUDE_OUTER", "rewrite_rules_structured": [{"conditions": "1. The query involves an INNER JOIN operation.\n2. The left input of the JOIN operation is a SELECT statement (represents a project operation in relational algebra) that potentially transforms the columns (e.g., SELECT a, b as b_renamed FROM table).", "transformations": "1. Identify the SELECT expressions in the project operation on the left input.\n2. Adjust the JOIN condition in the original query to reference these transformed columns directly.\n3. Write a new SELECT statement that combines the columns from both the left and right inputs of the JOIN, including any transformations applied in the original project operation.\n4. Ensure the JOIN condition now directly correlates with the underlying tables or subqueries without the intervening project operation."}, {"conditions": "1. The query involves an OUTER JOIN (LEFT OUTER JOIN, RIGHT OUTER JOIN) operation.\n2. The left input of the JOIN operation is a SELECT statement.\n3. Validate that the transformations applied in the project operation do not introduce incorrect nullability aspects on the preserved side of the JOIN.", "transformations": "1. Conduct a detailed analysis of the projection expressions to ensure they are compatible with OUTER JOIN semantics concerning nullability.\n2. Reformulate the SELECT statement to execute the project operation post-JOIN but preserve the conditions of correct null handling.\n3. Adjust the JOIN condition to reflect direct references to the outer side's columns considering the nullability constraints.\n4. Construct a new OUTER JOIN expression that directly utilizes the original tables or subqueries, subsequently applying the projection conditions."}]}
{"name": "AGGREGATE_FILTER_TRANSPOSE", "rewrite_rules_structured": [{"conditions": "If the SQL query contains a GROUP BY operation (Aggregate) on top of a WHERE clause (Filter) and the columns in the WHERE clause are not unique", "transformations": "1. Combining the columns used in the GROUP BY and WHERE clause into a new GROUP BY in a subquery.\n2. Applying the original WHERE clause as a HAVING clause in this subquery to filter aggregated results.\n3. The outer query remains the same, grouping with the original GROUP BY columns to maintain semantic correctness."}, {"conditions": "When the SQL query involves complex grouping (like `ROLLUP`, `CUBE`, or additional grouping sets) or requires additional columns not in the GROUP BY for the WHERE clause", "transformations": "1. Identify and split the aggregate operation into two parts:\n   - A bottom Aggregate representing a new GROUP BY in a subquery, combining original grouping columns and additional necessary columns from the WHERE clause, where the WHERE clause is converted into a HAVING clause for pre-filtering.\n   - A top Aggregate (if needed) over the bottom Aggregate to apply complex grouping sets or additional aggregations.\n2. The bottom Aggregate aims to reduce the number of rows by pre-aggregating and applying the filter early.\n3. The top Aggregate, if present, applies further aggregations or complex grouping logic as required by the original query."}]}
